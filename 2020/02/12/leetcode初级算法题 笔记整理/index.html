<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>leetcode初级算法——代码笔记整理 | Shuttworth's Zone</title><meta name="description" content="leetcode初级算法——代码笔记整理"><meta name="keywords" content="算法"><meta name="author" content="Shuttworth,shuttworth@foxmail.com"><meta name="copyright" content="Shuttworth"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="leetcode初级算法——代码笔记整理"><meta name="twitter:description" content="leetcode初级算法——代码笔记整理"><meta name="twitter:image" content="https://s2.ax1x.com/2020/02/12/1bnDPK.th.png"><meta property="og:type" content="article"><meta property="og:title" content="leetcode初级算法——代码笔记整理"><meta property="og:url" content="http://yoursite.com/2020/02/12/leetcode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%20%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"><meta property="og:site_name" content="Shuttworth's Zone"><meta property="og:description" content="leetcode初级算法——代码笔记整理"><meta property="og:image" content="https://s2.ax1x.com/2020/02/12/1bnDPK.th.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/02/12/leetcode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%20%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"><link rel="prev" title="安游记——济南青岛四日行" href="http://yoursite.com/2020/06/23/%E5%AE%89%E6%B8%B8%E8%AE%B0%E2%80%94%E2%80%94%E6%B5%8E%E5%8D%97%E9%9D%92%E5%B2%9B%E5%9B%9B%E6%97%A5%E8%A1%8C/"><link rel="next" title="《活着》读书笔记" href="http://yoursite.com/2020/02/12/%E3%80%8A%E6%B4%BB%E7%9D%80%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Shuttworth's Zone" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Shuttworth's Zone</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">6</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">3</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#leetcode初级算法——代码笔记整理"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">leetcode初级算法——代码笔记整理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#数组"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">数组</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#26-删除数组中的重复项"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">26.删除数组中的重复项</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#122-买卖股票的最佳时机"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">122.买卖股票的最佳时机</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#189-旋转数组"><span class="toc_mobile_items-number">1.1.3.</span> <span class="toc_mobile_items-text">189.旋转数组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#217-存在重复元素"><span class="toc_mobile_items-number">1.1.4.</span> <span class="toc_mobile_items-text">217. 存在重复元素</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#136-只出现一次的数字"><span class="toc_mobile_items-number">1.1.5.</span> <span class="toc_mobile_items-text">136.只出现一次的数字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#350-两个数组的交集"><span class="toc_mobile_items-number">1.1.6.</span> <span class="toc_mobile_items-text">350.两个数组的交集</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#66-加一"><span class="toc_mobile_items-number">1.1.7.</span> <span class="toc_mobile_items-text">66.加一</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#283-移动零"><span class="toc_mobile_items-number">1.1.8.</span> <span class="toc_mobile_items-text">283.移动零</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-两数之和"><span class="toc_mobile_items-number">1.1.9.</span> <span class="toc_mobile_items-text">1.两数之和</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#36-有效的数独"><span class="toc_mobile_items-number">1.1.10.</span> <span class="toc_mobile_items-text">36.有效的数独</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#48-旋转图像"><span class="toc_mobile_items-number">1.1.11.</span> <span class="toc_mobile_items-text">48.旋转图像</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#字符串"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">字符串</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#344-反转字符串"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">344.反转字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-整数反转"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">7.整数反转</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#387-字符串中的第一个唯一字符"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">387.字符串中的第一个唯一字符</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#242-有效的字母异位词"><span class="toc_mobile_items-number">1.2.4.</span> <span class="toc_mobile_items-text">242.有效的字母异位词</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#125-验证回文字符串"><span class="toc_mobile_items-number">1.2.5.</span> <span class="toc_mobile_items-text">125.验证回文字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-字符串转换整数-atoi"><span class="toc_mobile_items-number">1.2.6.</span> <span class="toc_mobile_items-text">8.字符串转换整数 (atoi)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#28-实现strstr"><span class="toc_mobile_items-number">1.2.7.</span> <span class="toc_mobile_items-text">28.实现strstr()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#38-外观数列"><span class="toc_mobile_items-number">1.2.8.</span> <span class="toc_mobile_items-text">38.外观数列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#14-最长公共前缀匹配"><span class="toc_mobile_items-number">1.2.9.</span> <span class="toc_mobile_items-text">14.最长公共前缀匹配</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#链表"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">链表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#237-删除链表中的节点"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">237.删除链表中的节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#19-删除链表的倒数第N个节点"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">19.删除链表的倒数第N个节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#206-反转链表"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">206.反转链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#21-合并两个有序链表"><span class="toc_mobile_items-number">1.3.4.</span> <span class="toc_mobile_items-text">21.合并两个有序链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#234-回文链表"><span class="toc_mobile_items-number">1.3.5.</span> <span class="toc_mobile_items-text">234.回文链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#141-环形链表"><span class="toc_mobile_items-number">1.3.6.</span> <span class="toc_mobile_items-text">141.环形链表</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#树"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#104-二叉树的最大深度"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">104.二叉树的最大深度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#98-验证二叉搜索树"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">98.验证二叉搜索树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#101-对称二叉树"><span class="toc_mobile_items-number">1.4.3.</span> <span class="toc_mobile_items-text">101.对称二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#102-二叉树的层次遍历"><span class="toc_mobile_items-number">1.4.4.</span> <span class="toc_mobile_items-text">102.二叉树的层次遍历</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#108-将有序数组转换为二叉搜索树"><span class="toc_mobile_items-number">1.4.5.</span> <span class="toc_mobile_items-text">108.将有序数组转换为二叉搜索树</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#排序和搜索"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">排序和搜索</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#88-合并两个有序数组"><span class="toc_mobile_items-number">1.5.1.</span> <span class="toc_mobile_items-text">88.合并两个有序数组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#278-第一个错误的版本"><span class="toc_mobile_items-number">1.5.2.</span> <span class="toc_mobile_items-text">278.第一个错误的版本</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#动态规划"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">动态规划</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#70-爬楼梯"><span class="toc_mobile_items-number">1.6.1.</span> <span class="toc_mobile_items-text">70.爬楼梯</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#121-买卖股票的最佳时机"><span class="toc_mobile_items-number">1.6.2.</span> <span class="toc_mobile_items-text">121.买卖股票的最佳时机</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#53-最大子序和"><span class="toc_mobile_items-number">1.6.3.</span> <span class="toc_mobile_items-text">53.最大子序和</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#198-打家劫舍"><span class="toc_mobile_items-number">1.6.4.</span> <span class="toc_mobile_items-text">198.打家劫舍</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#设计问题"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">设计问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#384-打乱数组"><span class="toc_mobile_items-number">1.7.1.</span> <span class="toc_mobile_items-text">384.打乱数组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#155-最小栈"><span class="toc_mobile_items-number">1.7.2.</span> <span class="toc_mobile_items-text">155.最小栈</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#数学"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">数学</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#412-Fizz-Buzz"><span class="toc_mobile_items-number">1.8.1.</span> <span class="toc_mobile_items-text">412.Fizz Buzz</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#204-计数质数"><span class="toc_mobile_items-number">1.8.2.</span> <span class="toc_mobile_items-text">204.计数质数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#326-3的幂"><span class="toc_mobile_items-number">1.8.3.</span> <span class="toc_mobile_items-text">326.  3的幂</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#13-罗马数字转整数"><span class="toc_mobile_items-number">1.8.4.</span> <span class="toc_mobile_items-text">13.罗马数字转整数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#其他"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">其他</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#191-位1的个数"><span class="toc_mobile_items-number">1.9.1.</span> <span class="toc_mobile_items-text">191.位1的个数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#461-汉明距离"><span class="toc_mobile_items-number">1.9.2.</span> <span class="toc_mobile_items-text">461.汉明距离</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#190-颠倒二进制位"><span class="toc_mobile_items-number">1.9.3.</span> <span class="toc_mobile_items-text">190.颠倒二进制位</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#118-帕斯卡三角-杨辉三角"><span class="toc_mobile_items-number">1.9.4.</span> <span class="toc_mobile_items-text">118.帕斯卡三角&#x2F;杨辉三角</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#20-有效的括号"><span class="toc_mobile_items-number">1.9.5.</span> <span class="toc_mobile_items-text">20.有效的括号</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#268-缺失数字"><span class="toc_mobile_items-number">1.9.6.</span> <span class="toc_mobile_items-text">268.缺失数字</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode初级算法——代码笔记整理"><span class="toc-number">1.</span> <span class="toc-text">leetcode初级算法——代码笔记整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">1.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-删除数组中的重复项"><span class="toc-number">1.1.1.</span> <span class="toc-text">26.删除数组中的重复项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122-买卖股票的最佳时机"><span class="toc-number">1.1.2.</span> <span class="toc-text">122.买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#189-旋转数组"><span class="toc-number">1.1.3.</span> <span class="toc-text">189.旋转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#217-存在重复元素"><span class="toc-number">1.1.4.</span> <span class="toc-text">217. 存在重复元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#136-只出现一次的数字"><span class="toc-number">1.1.5.</span> <span class="toc-text">136.只出现一次的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#350-两个数组的交集"><span class="toc-number">1.1.6.</span> <span class="toc-text">350.两个数组的交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-加一"><span class="toc-number">1.1.7.</span> <span class="toc-text">66.加一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#283-移动零"><span class="toc-number">1.1.8.</span> <span class="toc-text">283.移动零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-两数之和"><span class="toc-number">1.1.9.</span> <span class="toc-text">1.两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-有效的数独"><span class="toc-number">1.1.10.</span> <span class="toc-text">36.有效的数独</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-旋转图像"><span class="toc-number">1.1.11.</span> <span class="toc-text">48.旋转图像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">1.2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#344-反转字符串"><span class="toc-number">1.2.1.</span> <span class="toc-text">344.反转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-整数反转"><span class="toc-number">1.2.2.</span> <span class="toc-text">7.整数反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#387-字符串中的第一个唯一字符"><span class="toc-number">1.2.3.</span> <span class="toc-text">387.字符串中的第一个唯一字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#242-有效的字母异位词"><span class="toc-number">1.2.4.</span> <span class="toc-text">242.有效的字母异位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#125-验证回文字符串"><span class="toc-number">1.2.5.</span> <span class="toc-text">125.验证回文字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-字符串转换整数-atoi"><span class="toc-number">1.2.6.</span> <span class="toc-text">8.字符串转换整数 (atoi)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-实现strstr"><span class="toc-number">1.2.7.</span> <span class="toc-text">28.实现strstr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-外观数列"><span class="toc-number">1.2.8.</span> <span class="toc-text">38.外观数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-最长公共前缀匹配"><span class="toc-number">1.2.9.</span> <span class="toc-text">14.最长公共前缀匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-number">1.3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#237-删除链表中的节点"><span class="toc-number">1.3.1.</span> <span class="toc-text">237.删除链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-删除链表的倒数第N个节点"><span class="toc-number">1.3.2.</span> <span class="toc-text">19.删除链表的倒数第N个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#206-反转链表"><span class="toc-number">1.3.3.</span> <span class="toc-text">206.反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-合并两个有序链表"><span class="toc-number">1.3.4.</span> <span class="toc-text">21.合并两个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#234-回文链表"><span class="toc-number">1.3.5.</span> <span class="toc-text">234.回文链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#141-环形链表"><span class="toc-number">1.3.6.</span> <span class="toc-text">141.环形链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-number">1.4.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#104-二叉树的最大深度"><span class="toc-number">1.4.1.</span> <span class="toc-text">104.二叉树的最大深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-验证二叉搜索树"><span class="toc-number">1.4.2.</span> <span class="toc-text">98.验证二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#101-对称二叉树"><span class="toc-number">1.4.3.</span> <span class="toc-text">101.对称二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#102-二叉树的层次遍历"><span class="toc-number">1.4.4.</span> <span class="toc-text">102.二叉树的层次遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#108-将有序数组转换为二叉搜索树"><span class="toc-number">1.4.5.</span> <span class="toc-text">108.将有序数组转换为二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序和搜索"><span class="toc-number">1.5.</span> <span class="toc-text">排序和搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#88-合并两个有序数组"><span class="toc-number">1.5.1.</span> <span class="toc-text">88.合并两个有序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#278-第一个错误的版本"><span class="toc-number">1.5.2.</span> <span class="toc-text">278.第一个错误的版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划"><span class="toc-number">1.6.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#70-爬楼梯"><span class="toc-number">1.6.1.</span> <span class="toc-text">70.爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#121-买卖股票的最佳时机"><span class="toc-number">1.6.2.</span> <span class="toc-text">121.买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-最大子序和"><span class="toc-number">1.6.3.</span> <span class="toc-text">53.最大子序和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#198-打家劫舍"><span class="toc-number">1.6.4.</span> <span class="toc-text">198.打家劫舍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计问题"><span class="toc-number">1.7.</span> <span class="toc-text">设计问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#384-打乱数组"><span class="toc-number">1.7.1.</span> <span class="toc-text">384.打乱数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#155-最小栈"><span class="toc-number">1.7.2.</span> <span class="toc-text">155.最小栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数学"><span class="toc-number">1.8.</span> <span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#412-Fizz-Buzz"><span class="toc-number">1.8.1.</span> <span class="toc-text">412.Fizz Buzz</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#204-计数质数"><span class="toc-number">1.8.2.</span> <span class="toc-text">204.计数质数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#326-3的幂"><span class="toc-number">1.8.3.</span> <span class="toc-text">326.  3的幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-罗马数字转整数"><span class="toc-number">1.8.4.</span> <span class="toc-text">13.罗马数字转整数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">1.9.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#191-位1的个数"><span class="toc-number">1.9.1.</span> <span class="toc-text">191.位1的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#461-汉明距离"><span class="toc-number">1.9.2.</span> <span class="toc-text">461.汉明距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#190-颠倒二进制位"><span class="toc-number">1.9.3.</span> <span class="toc-text">190.颠倒二进制位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#118-帕斯卡三角-杨辉三角"><span class="toc-number">1.9.4.</span> <span class="toc-text">118.帕斯卡三角&#x2F;杨辉三角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-有效的括号"><span class="toc-number">1.9.5.</span> <span class="toc-text">20.有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#268-缺失数字"><span class="toc-number">1.9.6.</span> <span class="toc-text">268.缺失数字</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2020/02/12/1bnDPK.th.png)"><div id="post-info"><div id="post-title"><div class="posttitle">leetcode初级算法——代码笔记整理</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-02-12<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-02-15</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/leetcode/">leetcode</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="leetcode初级算法——代码笔记整理"><a href="#leetcode初级算法——代码笔记整理" class="headerlink" title="leetcode初级算法——代码笔记整理"></a>leetcode初级算法——代码笔记整理</h1><p>网址：<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/" target="_blank" rel="noopener">https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/</a></p>
<p>本文对应的leetcode题目采取的写法为：&lt;题号.题目名称&gt;     例如：26.删除数组中的重复项</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="26-删除数组中的重复项"><a href="#26-删除数组中的重复项" class="headerlink" title="26.删除数组中的重复项"></a>26.删除数组中的重复项</h3><p>双指针法，j前i后，初始时i=0.j=1；当a[i]与a[j]相同，j++；</p>
<p>a[j]与a[i]不同，i追上j的位置</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int removeDuplicates(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums.size() &lt;&#x3D; 1)</span><br><span class="line">            return nums.size();</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 1; j &lt; nums.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] !&#x3D; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                nums[i] &#x3D; nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i + 1; </span><br><span class="line">        &#x2F;&#x2F;return nums.size();&#x2F;&#x2F;error 数组的后半部分没清理赶紧，因此需要返回i+1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="122-买卖股票的最佳时机"><a href="#122-买卖股票的最佳时机" class="headerlink" title="122.买卖股票的最佳时机"></a>122.买卖股票的最佳时机</h3><p>采取贪心算法，只要第二天价格高就卖出；</p>
<p>注意初始数组为空的情况</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) </span><br><span class="line">    &#123;</span><br><span class="line">      int profit &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i + 1 &lt; prices.size(); ++i) </span><br><span class="line">        &#123;profit +&#x3D; max(prices[i + 1] - prices[i], 0);&#125;</span><br><span class="line">        return profit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189.旋转数组"></a>189.旋转数组</h3><p>旋转数组的低效写法是末尾出元素，开头入元素，舍弃；</p>
<p>高效写法的实质就是三次原地逆置数组，注意k值取模</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void rotate(vector&lt;int&gt; &amp;nums, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        reverse(nums.begin(), nums.end() - k % nums.size()); </span><br><span class="line">        reverse(nums.end() - k % nums.size(), nums.end());</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h3><p>存入set，用大小比较来巧妙解决是否有重复元素的元素；</p>
<p>注意每个分支if else后面都要有返回值，否则编译不通过</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        set&lt;int&gt;s1(nums.begin(),nums.end());</span><br><span class="line">        return nums.size()!&#x3D;s1.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h3><p>遍历+异或 ，位操作无比高效</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       int result&#x3D;0;</span><br><span class="line">       for(auto elm:nums)</span><br><span class="line">       &#123;</span><br><span class="line">           result^&#x3D;elm;</span><br><span class="line">       &#125;</span><br><span class="line">       return result; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="350-两个数组的交集"><a href="#350-两个数组的交集" class="headerlink" title="350.两个数组的交集"></a>350.两个数组的交集</h3><p>运用哈希表来完成，一个数组负责加，一个数组负责减</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">       vector&lt;int&gt;rec;</span><br><span class="line">       unordered_map&lt;int,int&gt;map;</span><br><span class="line">       for(int i &#x3D;0;i&lt;nums1.size();++i)</span><br><span class="line">           map[nums1[i]]+&#x3D;1; &#x2F;&#x2F;记录次数</span><br><span class="line">       for(int i &#x3D;0;i&lt;nums2.size();++i)&#123; &#x2F;&#x2F;map先记录A的，再比较B的，核心在于匹配一次之后权值-1，防止重复元素的干扰</span><br><span class="line">          if(map[nums2[i]]&gt;0)&#x2F;&#x2F;两个数组有交集</span><br><span class="line">          &#123;</span><br><span class="line">              rec.push_back(nums2[i]);</span><br><span class="line">              map[nums2[i]]-&#x3D;1;  &#x2F;&#x2F;防止同一个数组中的重复元素的困扰</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return rec;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="66-加一"><a href="#66-加一" class="headerlink" title="66.加一"></a>66.加一</h3><p>三种情况：</p>
<p>末尾无9，例如2548，直接++</p>
<p>末尾若干个9,例如299，9全变成0，第一个非9的数++</p>
<p>全部都是9，例如999，9全变成0，末尾添0，首位变成1</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; digits.size() - 1; i &gt;&#x3D; 0; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (digits[i] &#x3D;&#x3D; 9)</span><br><span class="line">                digits[i] &#x3D; 0;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                return digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits.push_back(0);</span><br><span class="line">        digits[0] &#x3D; 1;</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h3><p>遍历的时候，count记录零的个数，就地向前移动；</p>
<p>遍历结束之后，尾部count个元素令等于0；</p>
<p>以此实现原地改造数组</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void moveZeroes(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (size_t i &#x3D; 0; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] !&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i - count] &#x3D; nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (size_t i &#x3D; nums.size() - 1; i &gt; (nums.size() - count-1); --i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">       unordered_map&lt;int,int&gt;result;</span><br><span class="line">       vector&lt;int&gt;vec1;</span><br><span class="line">       for(int i&#x3D;0;i&lt;nums.size();++i)</span><br><span class="line">       &#123;</span><br><span class="line">           int need&#x3D;target-nums[i];</span><br><span class="line">           auto find1&#x3D;result.find(need);</span><br><span class="line">           if(find1!&#x3D;result.end())&#x2F;&#x2F;could find</span><br><span class="line">           &#123;</span><br><span class="line">               vec1.push_back(i);</span><br><span class="line">               vec1.push_back(find1-&gt;second);</span><br><span class="line">               break;</span><br><span class="line">           &#125;&#x2F;&#x2F;could not find</span><br><span class="line">           else result[nums[i]]&#x3D;i;&#x2F;&#x2F;insert 2,turn to 7,could find</span><br><span class="line">       &#125;</span><br><span class="line">       return vec1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36.有效的数独"></a>36.有效的数独</h3><p>本题颇具难度，需要花点时间思考；</p>
<p>本解法仍待提升，希望采取哈希的写法提升效率</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int getSquare(int i,int j)</span><br><span class="line">   &#123;</span><br><span class="line">       i&#x3D;i&#x2F;3;</span><br><span class="line">       j&#x3D;j&#x2F;3;</span><br><span class="line">       return i+3*j;</span><br><span class="line">   &#125;</span><br><span class="line">   bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">       vector&lt;vector&lt;int&gt;&gt; line(9, vector&lt;int&gt;(10, 0));&#x2F;&#x2F;共9行，每行10个数字对应0~9</span><br><span class="line">	vector&lt;vector&lt;int&gt;&gt; row(9, vector&lt;int&gt;(10, 0));&#x2F;&#x2F;9列</span><br><span class="line">	vector&lt;vector&lt;int&gt;&gt; square(9, vector&lt;int&gt;(10, 0));&#x2F;&#x2F;9个单元格</span><br><span class="line">       for(int i&#x3D;0;i&lt;9;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           for(int j&#x3D;0;j&lt;9;++j)</span><br><span class="line">           &#123;</span><br><span class="line">               if(board[i][j]&#x3D;&#x3D;&#39;.&#39;)</span><br><span class="line">               &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               int num&#x3D;board[i][j]-&#39;0&#39;;</span><br><span class="line">               if(line[i][num]&#x3D;&#x3D;0) &#123;++line[i][num];&#125;</span><br><span class="line">               else return false;</span><br><span class="line">               if(row[j][num]&#x3D;&#x3D;0) ++row[j][num];</span><br><span class="line">               else return false;</span><br><span class="line">               if(square[getSquare(i,j)][num]&#x3D;&#x3D;0)  ++square[getSquare(i,j)][num];</span><br><span class="line">               else return false;</span><br><span class="line">           &#125;   </span><br><span class="line">       &#125;</span><br><span class="line">           return true;</span><br><span class="line">   &#125;&#x2F;&#x2F;没有用哈希，因此效率不够好</span><br></pre></td></tr></table></figure></div>



<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h3><p>实质是原地旋转90度，<strong>仔细观察规律</strong><br>1.沿主对⻆角线所有元素交换<br>2.沿着垂直中轴线⽅方向所有元素交换</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">	for(int i &#x3D; 0; i &lt; matrix.size(); i++)</span><br><span class="line">		for(int j &#x3D; 0; j &lt;&#x3D; i; j++)</span><br><span class="line">			swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">	for(int i &#x3D; 0, j &#x3D; matrix.size() - 1; i &lt; j; i++, j--)</span><br><span class="line">		for(int k &#x3D; 0; k &lt; matrix.size(); k++)</span><br><span class="line">			swap(matrix[k][i], matrix[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<hr>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>遍历时引入temp交换即可</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void reverseString(vector&lt;char&gt;&amp; s) &#123;</span><br><span class="line">        char temp;</span><br><span class="line">        int size &#x3D; s.size();</span><br><span class="line">        for(int i&#x3D;0;i&lt;size&#x2F;2;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp&#x3D;s[i];</span><br><span class="line">            s[i]&#x3D;s[size-1-i];</span><br><span class="line">            s[size-1-i]&#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h3><p>原生反转其实很简单，三句话就可实现</p>
<p><strong>在防溢出这里的写法是值得学习的</strong></p>
<pre><code>//INT_MAX = 2^31-1=2147483647；
//INT_MIN= -2^31=-2147483648；</code></pre><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int reverse(int x) &#123;</span><br><span class="line">       int ret&#x3D;0;</span><br><span class="line">       while(x!&#x3D;0)</span><br><span class="line">       &#123;</span><br><span class="line">           int pop&#x3D;x%10;</span><br><span class="line">           x&#x2F;&#x3D;10;</span><br><span class="line">           if(ret&gt;INT_MAX&#x2F;10||(ret&#x3D;&#x3D;INT_MAX&#x2F;10&amp;&amp;pop&gt;7))return 0;</span><br><span class="line">           if(ret&lt;INT_MIN&#x2F;10||(ret&#x3D;&#x3D;INT_MIN&#x2F;10&amp;&amp;pop&lt;-8))return 0;</span><br><span class="line">           ret&#x3D;ret*10+pop;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387.字符串中的第一个唯一字符"></a>387.字符串中的第一个唯一字符</h3><p>两次遍历，遍历的精髓就在以数组下标i为变化量，两次都是以i来遍历，因为返回值是数组下标</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int firstUniqChar(string s) &#123;</span><br><span class="line">       map&lt;char,int&gt;mp1;</span><br><span class="line">       int length&#x3D;s.size();</span><br><span class="line">       for(int i&#x3D;0;i&lt;length;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           ++mp1[s[i]];</span><br><span class="line">       &#125;</span><br><span class="line">       for(int i&#x3D;0;i&lt;length;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           if(mp1[s[i]]&#x3D;&#x3D;1) return i;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;&#x2F;&#x2F;必不可少</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p>两个字符串，一个负责“加”，一个负责“减”</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if(s.size() !&#x3D; t.size())</span><br><span class="line">           return false;</span><br><span class="line">       int *alpha &#x3D; new int[26](); &#x2F;&#x2F;只包括小写字母</span><br><span class="line">       for(int i &#x3D; 0; i&lt; s.size(); i++) &#123;</span><br><span class="line">           alpha[s[i] - &#39;a&#39;] ++;</span><br><span class="line">           alpha[t[i] - &#39;a&#39;] --;</span><br><span class="line">       &#125; &#x2F;&#x2F;如果数目完全相同，则alpha所有位值都是0，一加一减的方法很巧妙</span><br><span class="line">       for(int i&#x3D;0;i&lt;26;i++)&#123;</span><br><span class="line">           if(alpha[i] !&#x3D; 0)</span><br><span class="line">           &#123;return false;&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="125-验证回文字符串"><a href="#125-验证回文字符串" class="headerlink" title="125.验证回文字符串"></a>125.验证回文字符串</h3><p>回文的特性决定了双指针的写法，一个从前往后一个从后往前</p>
<p>while内部的用法很细节，isalnum tolower很细节，把不纳入判断的元素过滤</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool isPalindrome(string s) &#123;</span><br><span class="line">       &#x2F;&#x2F; 双指针</span><br><span class="line">       if(s.size() &lt;&#x3D; 1) return true; &#x2F;&#x2F;空字符串返回true</span><br><span class="line">       int i &#x3D; 0, j &#x3D; s.size() - 1; &#x2F;&#x2F;一个头一个尾</span><br><span class="line">       while(i &lt; j)&#123;</span><br><span class="line">           while(i &lt; j &amp;&amp; !isalnum(s[i])) </span><br><span class="line">           &#x2F;&#x2F; 如果是合格字符，while（0）直接跳过，最后到了比对环节；如果是非合格字符，如逗号，while（1）执行i++，跳过了这个非字符元素，</span><br><span class="line">           &#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           while(i &lt; j &amp;&amp; !isalnum(s[j]))</span><br><span class="line">           &#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           if(tolower(s[i++]) !&#x3D; tolower(s[j--])) </span><br><span class="line">           &#x2F;&#x2F;统一转换成小写字母再比较，比对环节一旦出问题，直接return false；</span><br><span class="line">               return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8.字符串转换整数 (atoi)"></a>8.字符串转换整数 (atoi)</h3><p>这道题目细节之处很多，<strong>代码值得仔细研究</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int myAtoi(string str) &#123;</span><br><span class="line">       int ret&#x3D;0;</span><br><span class="line">       int i&#x3D;0;</span><br><span class="line">       int flag&#x3D;1;</span><br><span class="line">       while(str[i]&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">       &#123;</span><br><span class="line">           ++i;</span><br><span class="line">       &#125;</span><br><span class="line">       if(str[i]&#x3D;&#x3D;&#39;-&#39;)</span><br><span class="line">       &#123;</span><br><span class="line">           flag&#x3D;-1;</span><br><span class="line">       &#125;</span><br><span class="line">       if(str[i]&#x3D;&#x3D;&#39;+&#39;||str[i]&#x3D;&#x3D;&#39;-&#39;)</span><br><span class="line">       &#123;</span><br><span class="line">           ++i;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;数字处理这里十分细节</span><br><span class="line">       while(i&lt;str.size()&amp;&amp;isdigit(str[i]))</span><br><span class="line">       &#123;</span><br><span class="line">           int r&#x3D;str[i]-&#39;0&#39;;&#x2F;&#x2F;这里将字符数字转成实际数字，减去&#39;0&#39;</span><br><span class="line">           if(ret&gt;INT_MAX&#x2F;10||(ret&#x3D;&#x3D;INT_MAX&#x2F;10&amp;&amp;r&gt;7))</span><br><span class="line">           &#123;</span><br><span class="line">               return flag&gt;0?INT_MAX:INT_MIN;</span><br><span class="line">           &#125;</span><br><span class="line">           ret&#x3D;ret*10+r;</span><br><span class="line">           ++i;</span><br><span class="line">       &#125;</span><br><span class="line">       return flag&gt;0?ret:-ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="28-实现strstr"><a href="#28-实现strstr" class="headerlink" title="28.实现strstr()"></a>28.实现strstr()</h3><p>最暴力的解法是粗暴回退法，KMP是其改进</p>
<p><strong>对于solution里的KMP和dp KMP还需要钻研</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; getnext(string str)</span><br><span class="line">        &#123;</span><br><span class="line">            int len&#x3D;str.size();</span><br><span class="line">            vector&lt;int&gt; next;</span><br><span class="line">            next.push_back(-1);</span><br><span class="line">            int j&#x3D;0,k&#x3D;-1;</span><br><span class="line">            while(j&lt;len-1)</span><br><span class="line">            &#123;</span><br><span class="line">                if(k&#x3D;&#x3D;-1||str[j]&#x3D;&#x3D;str[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    k++;</span><br><span class="line">                    if(str[j]!&#x3D;str[k])</span><br><span class="line">                        next.push_back(k);</span><br><span class="line">                    else</span><br><span class="line">                        next.push_back(next[k]);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    k&#x3D;next[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    int strStr(string haystack, string needle) &#123;</span><br><span class="line">        if(needle.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        int j&#x3D;0;</span><br><span class="line">        int len1&#x3D;haystack.size();</span><br><span class="line">        int len2&#x3D;needle.size();</span><br><span class="line">        vector&lt;int&gt; next;</span><br><span class="line">        next&#x3D;getnext(needle);</span><br><span class="line">        while((i&lt;len1)&amp;&amp;(j&lt;len2))</span><br><span class="line">        &#123;</span><br><span class="line">            if((j&#x3D;&#x3D;-1)||(haystack[i]&#x3D;&#x3D;needle[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                j&#x3D;next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j&#x3D;&#x3D;len2)</span><br><span class="line">            return i-j;</span><br><span class="line">        </span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38.外观数列"></a>38.外观数列</h3><p>递归和出口、count计数、字符串拼接</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">string countAndSay(int n) &#123;</span><br><span class="line">       if(n&#x3D;&#x3D;1) return &quot;1&quot;;</span><br><span class="line">       string strlast&#x3D;countAndSay(n-1);</span><br><span class="line">       int count&#x3D;1;</span><br><span class="line">       string ret;</span><br><span class="line">       for(int i&#x3D;0;i&lt;strlast.size();++i)</span><br><span class="line">       &#123;</span><br><span class="line">           if(strlast[i]&#x3D;&#x3D;strlast[i+1])</span><br><span class="line">           &#123;</span><br><span class="line">               ++count;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               if(strlast[i]!&#x3D;strlast[i+1])</span><br><span class="line">               &#123;</span><br><span class="line">                   ret+&#x3D;to_string(count)+strlast[i];</span><br><span class="line">                   count&#x3D;1;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="14-最长公共前缀匹配"><a href="#14-最长公共前缀匹配" class="headerlink" title="14.最长公共前缀匹配"></a>14.最长公共前缀匹配</h3><p>先遍历，找到最短的字符串；再遍历最短字符串的每一个元素，如果和其他的相同位置元素不匹配，直接return false；全部匹配返回true；</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">       string ans &#x3D; &quot;&quot;;</span><br><span class="line">       if(strs.empty())    return ans; &#x2F;&#x2F;输入为空，输出空ans</span><br><span class="line">       int arr &#x3D; strs.size();</span><br><span class="line">       string min &#x3D; strs[0];</span><br><span class="line">       for(int i &#x3D; 1; i &lt; arr; ++ i) &#x2F;&#x2F;找到最短字符串</span><br><span class="line">       &#123;</span><br><span class="line">           if(strs[i].size() &lt; min.size())</span><br><span class="line">               min &#x3D; strs[i];</span><br><span class="line">       &#125;</span><br><span class="line">       for(int j &#x3D; 0; j &lt; min.size(); ++ j) </span><br><span class="line">       &#x2F;&#x2F;从第一个字符开始对比，若都一样，ans加上该字符，若不一样，返回答案；</span><br><span class="line">       &#123;</span><br><span class="line">           for(int m &#x3D; 0; m &lt; arr; ++m)</span><br><span class="line">           &#123;</span><br><span class="line">               if(min[j] !&#x3D; strs[m][j])</span><br><span class="line">                   return ans; &#x2F;&#x2F;错误就直接返回</span><br><span class="line">           &#125;</span><br><span class="line">           ans &#x3D; ans + min[j]; &#x2F;&#x2F;全部对上了就把内容加上</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<hr>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h3><p>很简单，略过，不断链即可</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void deleteNode(ListNode* node) &#123; &#x2F;&#x2F;已经定义好了这个ListNode结构体，并且把要删除的结点传了进来</span><br><span class="line">       *node&#x3D;*(node-&gt;next);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p>双指针法是链表中常用的技术手段</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">       &#x2F;&#x2F;如果用两次遍历法，也应该先创建个头结点</span><br><span class="line">       ListNode* former&#x3D;new ListNode(0);</span><br><span class="line">       former-&gt;next&#x3D;head;&#x2F;&#x2F;这次尝试双指针法</span><br><span class="line">       ListNode * p&#x3D;former;</span><br><span class="line">       ListNode * q&#x3D;former;&#x2F;&#x2F;这里都要从former开始,避免了初始1个元素就删除这一个元素的情况</span><br><span class="line">       int count&#x3D;0;</span><br><span class="line">       while(count&lt;n)</span><br><span class="line">       &#123;</span><br><span class="line">           ++count;</span><br><span class="line">           q&#x3D;q-&gt;next;</span><br><span class="line">       &#125; &#x2F;&#x2F;先把p q偏移好一定的位置</span><br><span class="line">       while(q-&gt;next!&#x3D;NULL)</span><br><span class="line">       &#123;</span><br><span class="line">           q&#x3D;q-&gt;next;</span><br><span class="line">           p&#x3D;p-&gt;next;</span><br><span class="line">       &#125;&#x2F;&#x2F;p q 一起右移，直到q移到最后一个元素位置</span><br><span class="line">       ListNode * del&#x3D;p-&gt;next;&#x2F;&#x2F;写这步的目的是del删除节点，回收资源。否则直接双next写法</span><br><span class="line">       p-&gt;next&#x3D;del-&gt;next;</span><br><span class="line">       delete del;</span><br><span class="line">       ListNode * ret&#x3D;former-&gt;next;</span><br><span class="line">       delete former;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p>递归的写法，如图</p>
<p><a href="https://s2.ax1x.com/2020/02/12/1HsnPK.gif" target="_blank" rel="noopener" data-fancybox="group" data-caption="1HsnPK.gif" class="fancybox"><img alt="1HsnPK.gif" title="1HsnPK.gif" data-src="https://s2.ax1x.com/2020/02/12/1HsnPK.gif" class="lazyload"></a></p>
<p>一次遍历，边遍历边修改的写法是最好 </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">       if(head&#x3D;&#x3D;nullptr)</span><br><span class="line">       &#123;</span><br><span class="line">           return head;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode * first &#x3D; head;</span><br><span class="line">       ListNode * target &#x3D; first-&gt;next;</span><br><span class="line">       while(target!&#x3D;nullptr)</span><br><span class="line">       &#123;</span><br><span class="line">           first-&gt;next&#x3D;target-&gt;next;</span><br><span class="line">           ListNode * temp &#x3D; target-&gt;next;</span><br><span class="line">           target-&gt;next&#x3D;head;</span><br><span class="line">           head&#x3D;target;</span><br><span class="line">           target&#x3D;temp;</span><br><span class="line">       &#125;</span><br><span class="line">       return head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h3><p><strong>精髓思想</strong>是，不改变原有的两个链表的本来指向，新定义一个指针，规定其指向，不断把满足要求的结点添加到其后面</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">       ListNode * former &#x3D; new ListNode(-1);</span><br><span class="line">       ListNode * curnode &#x3D; former;</span><br><span class="line">       while(l1!&#x3D;nullptr&amp;&amp;l2!&#x3D;nullptr)</span><br><span class="line">       &#123;</span><br><span class="line">           if(l1-&gt;val&gt;l2-&gt;val)</span><br><span class="line">           &#123;</span><br><span class="line">               curnode-&gt;next&#x3D;l2;</span><br><span class="line">               l2&#x3D;l2-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               curnode-&gt;next&#x3D;l1;</span><br><span class="line">               l1&#x3D;l1-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           curnode &#x3D; curnode -&gt; next;</span><br><span class="line">       &#125;</span><br><span class="line">       curnode-&gt;next&#x3D; l1&#x3D;&#x3D;nullptr ? l2:l1;</span><br><span class="line">       return former-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h3><p>尝试用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题，<strong>待参考柳婼的解法来补充完整</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h3><p>set容器存储指向结点的指针，遍历这个容器，找得到则有环，找不到则无环</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool hasCycle(ListNode *head) &#123;</span><br><span class="line">       if(head&#x3D;&#x3D;nullptr||head-&gt;next&#x3D;&#x3D;nullptr)</span><br><span class="line">       &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       set&lt;ListNode*&gt;nodeset;&#x2F;&#x2F;set容器内部装指针</span><br><span class="line">       while(head-&gt;next!&#x3D;nullptr)&#x2F;&#x2F;遍历</span><br><span class="line">       &#123;</span><br><span class="line">           if(nodeset.count(head)!&#x3D;0)&#x2F;&#x2F;有这个节点，直接就是环了</span><br><span class="line">           &#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               nodeset.insert(head);&#x2F;&#x2F;没有这个节点就插入</span><br><span class="line">           &#125;</span><br><span class="line">           head&#x3D;head-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;&#x2F;&#x2F;遍历完以后，都没有这个节点，就是没有环</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<hr>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的操作常用到递归和迭代的写法，这和树的特性有关；递归的效率比较低，如果可以改进写法，效率能够提升</p>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><p>左右各一个遍历记录值，递归+=，返回最大值</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int maxDepth(TreeNode *root)</span><br><span class="line">   &#123;</span><br><span class="line">       if (root &#x3D;&#x3D; nullptr)</span><br><span class="line">           return 0;</span><br><span class="line">       &#x2F;&#x2F;用递归来写</span><br><span class="line">       int depth_l &#x3D; 1;</span><br><span class="line">       int depth_r &#x3D; 1;</span><br><span class="line">       depth_l +&#x3D; maxDepth(root-&gt;left);</span><br><span class="line">       depth_r +&#x3D; maxDepth(root-&gt;right);</span><br><span class="line">       return depth_l &gt; depth_r ? depth_l : depth_r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p>利用二叉搜索树满足的特性：</p>
<p><strong>中序遍历</strong>存数据进入vec数组，对数组遍历看是否是升序，是则合格</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void inorder(TreeNode * root,vector&lt;int&gt;&amp; vec)</span><br><span class="line">  &#123;</span><br><span class="line">      if(root&#x3D;&#x3D;NULL)return ;</span><br><span class="line">      inorder(root-&gt;left,vec);</span><br><span class="line">      vec.push_back(root-&gt;val);</span><br><span class="line">      inorder(root-&gt;right,vec);</span><br><span class="line">  &#125;</span><br><span class="line">  bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">      vector&lt;int&gt;vec;</span><br><span class="line">      inorder(root,vec);</span><br><span class="line">      for(int i&#x3D;1;i&lt;vec.size();++i)</span><br><span class="line">      &#123;</span><br><span class="line">          if(vec[i]&lt;&#x3D;vec[i-1]) return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><p>总函数 isSymmetric借助辅助函数 helper，辅助函数内部写好边界再递归，这样的设计思想需要学习</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool helper(TreeNode * l , TreeNode * r)</span><br><span class="line">  &#123;</span><br><span class="line">      if(l&#x3D;&#x3D;NULL&amp;&amp;r&#x3D;&#x3D;NULL) return true;</span><br><span class="line">      if(l&#x3D;&#x3D;NULL||r&#x3D;&#x3D;NULL) return false;</span><br><span class="line">      if(l-&gt;val!&#x3D;r-&gt;val) return false;</span><br><span class="line">      return helper(l-&gt;left,r-&gt;right)&amp;helper(l-&gt;right,r-&gt;left); &#x2F;&#x2F;这句话是精髓</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">      if(!root) return true;</span><br><span class="line">      return helper(root-&gt;left,root-&gt;right);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102.二叉树的层次遍历"></a>102.二叉树的层次遍历</h3><p>用数组vector和队列queue解决</p>
<p>队列牢牢地掌控了层次遍历的顺序</p>
<p>vector<int>为了vector&lt;vector<int>&gt;服务</int></int></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode *root)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; row;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        if (root &#x3D;&#x3D; NULL)</span><br><span class="line">            return ret;</span><br><span class="line">        TreeNode *temp;</span><br><span class="line">        que.push(root);</span><br><span class="line">        while (!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int size &#x3D; que.size();</span><br><span class="line">            while (size--) &#x2F;&#x2F;把同一层的放到一起</span><br><span class="line">            &#123;</span><br><span class="line">                temp &#x3D; que.front(); &#x2F;&#x2F;先留个号码，好找</span><br><span class="line">                que.pop();          &#x2F;&#x2F;再出队</span><br><span class="line">                row.push_back(temp-&gt;val);</span><br><span class="line">                if (temp-&gt;left !&#x3D; NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (temp-&gt;right !&#x3D; NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(row);</span><br><span class="line">            row.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><p>核心在于有序数组的中间值是根节点，代码虽短，细节不少</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty()) return nullptr;</span><br><span class="line">        return helper(nums,0,nums.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode * helper(vector&lt;int&gt;&amp;nums,int left,int right)</span><br><span class="line">    &#123;</span><br><span class="line">        if(left&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid&#x3D;(left+right)&#x2F;2; &#x2F;&#x2F;升序的有序数组变成平衡二叉树，根节点一定在中点的位置</span><br><span class="line">        TreeNode * root &#x3D; new TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left&#x3D;helper(nums,left,mid-1);</span><br><span class="line">        root-&gt;right&#x3D;helper(nums,mid+1,right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<hr>
<h2 id="排序和搜索"><a href="#排序和搜索" class="headerlink" title="排序和搜索"></a>排序和搜索</h2><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h3><p>几个边界，写错了两次，需要多注意</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">       if(!m) &#123;</span><br><span class="line">           swap(nums1,nums2);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       if(!n)&#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       int k1&#x3D;m-1;</span><br><span class="line">       int k2&#x3D;n-1;</span><br><span class="line">       int k3&#x3D;n+m-1;</span><br><span class="line">       while(k1&gt;&#x3D;0&amp;&amp;k2&gt;&#x3D;0)</span><br><span class="line">       &#123;</span><br><span class="line">           &#x2F;&#x2F;前面是判断，后面是执行</span><br><span class="line">           nums1[k3--]&#x3D;nums1[k1]&gt;nums2[k2]?nums1[k1--]:nums2[k2--];</span><br><span class="line">       &#125;</span><br><span class="line">       while(k2&gt;&#x3D;0)</span><br><span class="line">       &#123;</span><br><span class="line">           nums1[k3--]&#x3D;nums2[k2--];</span><br><span class="line">       &#125;&#x2F;&#x2F;避免nums1走完，nums2没走完的情况</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278.第一个错误的版本"></a>278.第一个错误的版本</h3><p>二分查找法，可以通过递归和迭代两种方式实现</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int firstBadVersion(int n) &#123;</span><br><span class="line">       &#x2F;&#x2F;第一直觉是写一个二分查找</span><br><span class="line">       int left&#x3D;1;</span><br><span class="line">       int right&#x3D;n;</span><br><span class="line">       while(left&lt;right)&#x2F;&#x2F;直到left&#x3D;&#x3D;right,找到第一个地方</span><br><span class="line">       &#123;</span><br><span class="line">           int mid&#x3D;left+(right-left)&#x2F;2;&#x2F;&#x2F;避免溢出的精髓之处</span><br><span class="line">           if(isBadVersion(mid)&#x3D;&#x3D;false)</span><br><span class="line">           &#123;</span><br><span class="line">               left&#x3D;mid+1;</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               right&#x3D;mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return left;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<hr>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><p>如何爬上第n节台阶？可以由第n-1节爬一格上来，也可以由n-2节爬2格子上来</p>
<p>方针：“借助过去，实现现在”</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int climbStairs(int n) &#123;</span><br><span class="line">       int * a &#x3D; new int[n+1];</span><br><span class="line">       a[0]&#x3D;1; &#x2F;&#x2F;把n从0开始的所有情况，涵盖了进来</span><br><span class="line">       a[1]&#x3D;1;</span><br><span class="line">       for(int i&#x3D;2;i&lt;&#x3D;n;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           a[i]&#x3D;a[i-1]+a[i-2];</span><br><span class="line">       &#125;</span><br><span class="line">       return a[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h3><p>一次遍历实现，之前记录的profit为现在的ret提供了参考</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        int profit;</span><br><span class="line">        int minpr&#x3D;99999;</span><br><span class="line">        for(int i&#x3D;0;i&lt;prices.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            minpr&#x3D;min(prices[i],minpr);</span><br><span class="line">            profit&#x3D;prices[i]-minpr;</span><br><span class="line">            ret&#x3D;max(profit,ret);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3><p>之前的累加值为现在的选择做出了参考</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       int len &#x3D; nums.size();</span><br><span class="line">       if(len&#x3D;&#x3D;0) return 0;</span><br><span class="line">       int ans &#x3D; nums[0] ;</span><br><span class="line">       int temp &#x3D; nums[0];</span><br><span class="line">       for(int i&#x3D;1;i&lt;len;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           if(temp&gt;0)&#123;</span><br><span class="line">               temp&#x3D;temp+nums[i]; &#x2F;&#x2F;累加值存在temp中，当temp为正，无条件往后累加</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               temp&#x3D;nums[i]; &#x2F;&#x2F;之前的累加值为负，证明是失败的，重新赋予新的累加值temp</span><br><span class="line">           &#125;</span><br><span class="line">           ans&#x3D;max(ans,temp); &#x2F;&#x2F;只返回历史中最大的那个累加值</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h3><p>充分体现动态规划记录数据特性的一道题，<strong>解法值得推敲</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       int n &#x3D; nums.size();</span><br><span class="line">       if(!n) return 0;</span><br><span class="line">       if(n&#x3D;&#x3D;1) return nums[0];</span><br><span class="line">       &#x2F;&#x2F;以三个元素举例，房子1小于房子2价格，现在来到了房子3</span><br><span class="line">       int curmax&#x3D;0;&#x2F;&#x2F;房子2价格</span><br><span class="line">       int premax&#x3D;0;&#x2F;&#x2F;房子1价格</span><br><span class="line">       for(int x:nums)</span><br><span class="line">       &#123;</span><br><span class="line">           int temp&#x3D;curmax;</span><br><span class="line">           curmax&#x3D;max(curmax,(premax+x));</span><br><span class="line">           premax&#x3D;temp;</span><br><span class="line">       &#125;&#x2F;&#x2F;三个int型数据完成全部内容</span><br><span class="line">       return curmax;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<hr>
<h2 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h2><p>关于设计的这两道题，自己需要加类的成员函数，加类的私有对象</p>
<h3 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384.打乱数组"></a>384.打乱数组</h3><p>涉及到数组的提前保存和随机数的取得，随机数取得后与还未出场的数进行交换</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt;_nums;</span><br><span class="line">    vector&lt;int&gt;_origin;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    Solution(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        this-&gt;_nums&#x3D;nums;</span><br><span class="line">        this-&gt;_origin&#x3D;nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Resets the array to its original configuration and return it. *&#x2F;</span><br><span class="line">    vector&lt;int&gt; reset() &#123;</span><br><span class="line">        return this-&gt;_origin;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns a random shuffling of the array. *&#x2F;</span><br><span class="line">    vector&lt;int&gt; shuffle() &#123;</span><br><span class="line">        int len&#x3D;_nums.size();</span><br><span class="line">        if(!len) return _nums;</span><br><span class="line">        for(int i&#x3D;len-1;i&gt;&#x3D;0;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            int random &#x3D; rand()%(i+1);</span><br><span class="line">            swap(_nums[random],_nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return _nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h3><p>借用辅助栈来实现以空间换时间</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt;sta;</span><br><span class="line">    stack&lt;int&gt;min;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        sta.push(x);</span><br><span class="line">        if(min.empty()||x&lt;&#x3D;min.top()) &#x2F;&#x2F;&#x3D;防止出现连续两个最小的-10</span><br><span class="line">        &#123;</span><br><span class="line">            min.push(x);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(sta.top()&#x3D;&#x3D;min.top())</span><br><span class="line">        &#123;</span><br><span class="line">            min.pop();</span><br><span class="line">        &#125;    </span><br><span class="line">            sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        return sta.top();    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int getMin() &#123;</span><br><span class="line">        return min.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<hr>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412.Fizz Buzz"></a>412.Fizz Buzz</h3><p>数学问题，对症下药</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; fizzBuzz(int n)</span><br><span class="line">   &#123;</span><br><span class="line">       vector&lt;string&gt; ret;</span><br><span class="line">       for (int i &#x3D; 1; i &lt;&#x3D; n; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">           if (i % 15 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">               ret.push_back(&quot;FizzBuzz&quot;);</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if (i % 3 &#x3D;&#x3D; 0 )&#123;</span><br><span class="line">               ret.push_back(&quot;Fizz&quot;);</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if (i % 5 &#x3D;&#x3D; 0 )&#123;</span><br><span class="line">               ret.push_back(&quot;Buzz&quot;);</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               ret.push_back(to_string(i));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204.计数质数"></a>204.计数质数</h3><p>关于质数，有个很神奇的筛法，叫<strong>“厄拉多塞筛法”</strong></p>
<p>核心思想是，当一个数确定为质数后，它的倍数全部都不会是质数，筛掉</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int countPrimes(int n) &#123;</span><br><span class="line">       int count&#x3D;0;</span><br><span class="line">       vector&lt;bool&gt;vec(n,true);</span><br><span class="line">       for(int i&#x3D;2;i&lt;n;++i)&#x2F;&#x2F;从2这第一个质数开始</span><br><span class="line">       &#123;</span><br><span class="line">           if(vec[i])</span><br><span class="line">           &#123;</span><br><span class="line">               ++count;</span><br><span class="line">               for(int j&#x3D;i+i;j&lt;n;j+&#x3D;i)</span><br><span class="line">               &#123;</span><br><span class="line">                   vec[j]&#x3D;false;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>优化操作：用bitmap对筛选算法进行内存优化</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int countPrimes(int n) &#123;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;一个 int 变量不知道占多少字节（但请注意，这里采用了常量）</span><br><span class="line">    const int size &#x3D; sizeof(int) * 8;</span><br><span class="line">    vector&lt;int&gt; signs(n &#x2F; size + 1,0);</span><br><span class="line">    for (int i &#x3D; 2; i &lt; n; i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;将元素和需确定得数字经行按位或运算，如果值改变，说明不存在该数字（未登记该数字），则其为质数。</span><br><span class="line">        &#x2F;&#x2F;在C++中，其提供了 bitset 来操作位，在此便不做介绍了。如果用了，可读性肯定会更好。</span><br><span class="line">        &#x2F;&#x2F;(当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值)</span><br><span class="line">        &#x2F;&#x2F;*如果 x &#x3D; 2^n ，则 x &amp; (n - 1) &#x3D;&#x3D; x % n</span><br><span class="line">        &#x2F;&#x2F;下面判断可以写成</span><br><span class="line">        &#x2F;&#x2F;if ((signs[i &#x2F; size] &amp; (1 &lt;&lt; (i % 32))) &#x3D;&#x3D; 0)</span><br><span class="line">        if ((signs[i &#x2F; size] &amp; (1 &lt;&lt; (i &amp; (size - 1)))) &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            for (int j &#x3D; i + i; j &lt; n; j +&#x3D; i)&#123;</span><br><span class="line">                &#x2F;&#x2F;登记该数字</span><br><span class="line">                signs[j &#x2F; size] |&#x3D; 1 &lt;&lt; (j &amp; (size - 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326.  3的幂"></a>326.  3的幂</h3><p>有很多迭代和递归的写法，这里提供的是非循环和迭代的写法，更为优秀</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">	bool isPowerOfThree(int n) &#123;</span><br><span class="line">	if(n &lt;&#x3D; 0) return false;</span><br><span class="line">	return pow(3, (round)(log(n) &#x2F; log(3))) &#x3D;&#x3D; n; &#x2F;&#x2F;如果是3的幂次，一定是整数次幂</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h3><p>要点：pair的用法 || 罗马数字摆放的本质规律</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int romanToInt(string s) &#123;</span><br><span class="line">       int ans&#x3D;0;</span><br><span class="line">       map&lt;char,int&gt;mp;</span><br><span class="line">       char roman[]&#x3D;&#123;&#39;I&#39;,&#39;V&#39;,&#39;X&#39;,&#39;L&#39;,&#39;C&#39;,&#39;D&#39;,&#39;M&#39;&#125;;</span><br><span class="line">       int val[]&#x3D;&#123;1,5,10,50,100,500,1000&#125;;</span><br><span class="line">       for(int i&#x3D;0;i&lt;7;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           mp.insert(pair&lt;char,int&gt;(roman[i],val[i]));</span><br><span class="line">       &#125;</span><br><span class="line">       for(int i&#x3D;0;i&lt;s.size()-1;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           if(mp[s[i]]&gt;&#x3D;mp[s[i+1]])&#123;</span><br><span class="line">               ans+&#x3D;mp[s[i]];</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               ans-&#x3D;mp[s[i]];</span><br><span class="line">           &#125;&#x2F;&#x2F;成功解决IX类型写法，看透了本质</span><br><span class="line">       &#125;</span><br><span class="line">       ans+&#x3D;mp[s[s.size()-1]];</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191.位1的个数"></a>191.位1的个数</h3><p>涉及到“位bit”，与或非操作不可忘！</p>
<p>迭代法是基础</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int hammingWeight(uint32_t n)  &#x2F;&#x2F;传进来的是32位的2进制数</span><br><span class="line">   &#123; 	</span><br><span class="line">       int ret &#x3D; 0;</span><br><span class="line">       uint32_t mask &#x3D; 1;</span><br><span class="line">       for (int i &#x3D; 0; i &lt; 32; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">           if ((n &amp; mask) !&#x3D; 0)</span><br><span class="line">           &#123;</span><br><span class="line">               ++ret;</span><br><span class="line">           &#125;</span><br><span class="line">           mask &#x3D; mask &lt;&lt; 1;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461.汉明距离"></a>461.汉明距离</h3><p>实质是找出有几个位是不同的，异或、与操作、算术右移</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int hammingDistance(int x, int y) &#123;</span><br><span class="line">       int count&#x3D;0;</span><br><span class="line">       int xor1&#x3D;x^y;&#x2F;&#x2F;异或后，不同的位留下的都是1</span><br><span class="line">       while(xor1&gt;0)</span><br><span class="line">       &#123;</span><br><span class="line">           if(xor1&amp;1&#x3D;&#x3D;1)&#x2F;&#x2F;把所有的1数出来，用与的方法</span><br><span class="line">           &#123;</span><br><span class="line">               ++count; </span><br><span class="line">           &#125;</span><br><span class="line">           xor1&gt;&gt;&#x3D;1; &#x2F;&#x2F;算术右移一位</span><br><span class="line">       &#125;</span><br><span class="line">       return count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190.颠倒二进制位"></a>190.颠倒二进制位</h3><p>pop || x || ret 经典搭配，实现 逆置一个数</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint32_t reverseBits(uint32_t n) &#123;</span><br><span class="line">       uint32_t ret &#x3D; 0;</span><br><span class="line">       uint32_t pop &#x3D; 0;</span><br><span class="line">       for(int i&#x3D;0;i&lt;32;++i)&#123;</span><br><span class="line">           pop&#x3D;n%2;</span><br><span class="line">           n&#x3D;n&#x2F;2;</span><br><span class="line">           ret&#x3D;ret*2+pop;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="118-帕斯卡三角-杨辉三角"><a href="#118-帕斯卡三角-杨辉三角" class="headerlink" title="118.帕斯卡三角/杨辉三角"></a>118.帕斯卡三角/杨辉三角</h3><p>考察vector创建二维数组的操作，<strong>需要多练</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">	vector&lt;vector&lt;int&gt;&gt; v(numRows);</span><br><span class="line">	if(numRows &#x3D;&#x3D; 0) return v;</span><br><span class="line">	for(int i &#x3D; 0; i &lt; numRows; i++) &#123;</span><br><span class="line">		v[i].resize(i + 1);</span><br><span class="line">	&#125;</span><br><span class="line">	v[0][0] &#x3D; 1;</span><br><span class="line">	if(numRows &#x3D;&#x3D; 1) return v;</span><br><span class="line">	v[1][0] &#x3D; 1;</span><br><span class="line">	v[1][1] &#x3D; 1;</span><br><span class="line">	for(int i &#x3D; 2; i &lt; numRows; i++) &#123;</span><br><span class="line">	v[i][0] &#x3D; 1;</span><br><span class="line">	v[i][i] &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i &#x3D; 2; i &lt; numRows; i++) &#123;</span><br><span class="line">		for(int j &#x3D; 1; j &lt; i; j++) &#123;</span><br><span class="line">			v[i][j] &#x3D; v[i - 1][j - 1] + v[i - 1][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><p>核心是栈的入栈和出栈</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool isValid(string s) &#123;</span><br><span class="line">      stack&lt;char&gt;sta;</span><br><span class="line">      int len &#x3D; s.size();</span><br><span class="line">      if(!len) return true;</span><br><span class="line">      if(len%2&#x3D;&#x3D;1) return false;&#x2F;&#x2F;先把边界条件写好</span><br><span class="line">      for(int i&#x3D;0;i&lt;len;++i)&#123;</span><br><span class="line">           if(sta.empty())&#123;</span><br><span class="line">               sta.push(s[i]);</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if(sta.top()&#x3D;&#x3D;&#39;(&#39;&amp;&amp;s[i]&#x3D;&#x3D;&#39;)&#39;)&#123;</span><br><span class="line">               sta.pop();</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if(sta.top()&#x3D;&#x3D;&#39;[&#39;&amp;&amp;s[i]&#x3D;&#x3D;&#39;]&#39;)&#123;</span><br><span class="line">               sta.pop();</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if(sta.top()&#x3D;&#x3D;&#39;&#123;&#39;&amp;&amp;s[i]&#x3D;&#x3D;&#39;&#125;&#39;)&#123;</span><br><span class="line">               sta.pop();</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           sta.push(s[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      return sta.empty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>





<h3 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268.缺失数字"></a>268.缺失数字</h3><p>观察规律，然后解决</p>
<p>代码里写了两种遍历方式，后者效率更高</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       int len&#x3D;nums.size();</span><br><span class="line">       int total&#x3D;(0+len)*(len+1)&#x2F;2;</span><br><span class="line">       for(int x : nums)</span><br><span class="line">       &#123;</span><br><span class="line">           total-&#x3D;x;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; for(int i&#x3D;0;i&lt;len;++i)</span><br><span class="line">       &#x2F;&#x2F; &#123;</span><br><span class="line">       &#x2F;&#x2F;     total-&#x3D;nums[i];</span><br><span class="line">       &#x2F;&#x2F; &#125;</span><br><span class="line">       return total;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:shuttworth@foxmail.com">Shuttworth</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/02/12/leetcode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%20%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/">http://yoursite.com/2020/02/12/leetcode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%20%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Shuttworth's Zone</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法    </a></div><div class="post_share"><div class="social-share" data-image="https://s2.ax1x.com/2020/02/12/1bnDPK.th.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/23/%E5%AE%89%E6%B8%B8%E8%AE%B0%E2%80%94%E2%80%94%E6%B5%8E%E5%8D%97%E9%9D%92%E5%B2%9B%E5%9B%9B%E6%97%A5%E8%A1%8C/"><img class="prev_cover lazyload" data-src="https://s1.ax1x.com/2020/06/23/NUXhLR.th.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>安游记——济南青岛四日行</span></div></a></div><div class="next-post pull_right"><a href="/2020/02/12/%E3%80%8A%E6%B4%BB%E7%9D%80%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><img class="next_cover lazyload" data-src="https://s1.ax1x.com/2020/04/05/GBM0ln.th.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>《活着》读书笔记</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Shuttworth</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>