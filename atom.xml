<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shuttworth&#39;s Zone</title>
  <icon>https://www.gravatar.com/avatar/062bb21e4e20dd80a17ddbb09b4dccf3</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-21T14:45:25.564Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Shuttworth</name>
    <email>shuttworth@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>游记——济南青岛四天行</title>
    <link href="http://yoursite.com/2020/06/23/%E6%B8%B8%E8%AE%B0%E2%80%94%E2%80%94%E6%B5%8E%E5%8D%97%E9%9D%92%E5%B2%9B%E5%9B%9B%E5%A4%A9%E8%A1%8C/"/>
    <id>http://yoursite.com/2020/06/23/%E6%B8%B8%E8%AE%B0%E2%80%94%E2%80%94%E6%B5%8E%E5%8D%97%E9%9D%92%E5%B2%9B%E5%9B%9B%E5%A4%A9%E8%A1%8C/</id>
    <published>2020-06-23T04:55:24.188Z</published>
    <updated>2020-06-21T14:45:25.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总行程安排"><a href="#总行程安排" class="headerlink" title="总行程安排"></a>总行程安排</h2><p>济南玩一天（15中午-16号上午）</p><p>青岛玩三天（16中午-19号凌晨）</p><h2 id="济南游玩"><a href="#济南游玩" class="headerlink" title="济南游玩"></a>济南游玩</h2><h3 id="入住"><a href="#入住" class="headerlink" title="入住"></a>入住</h3><p>2020年6月15日早上乘火车出发，中午抵达济南，入住泉城路的汉庭优佳，酒店的位置就在宽厚里附近</p><p>汉庭优佳和全季酒店是我出门旅游最喜欢订的酒店，服务好环境干净，在华住app上用金会员预定的，送早餐，门店8.8折，可以延迟退房</p><p><a href="https://s1.ax1x.com/2020/06/20/NQAuCQ.png" data-fancybox="group" data-caption="NQAuCQ.png" class="fancybox"><img alt="NQAuCQ.png" title="NQAuCQ.png" data-src="https://s1.ax1x.com/2020/06/20/NQAuCQ.png" class="lazyload"></a></p><h3 id="出游"><a href="#出游" class="headerlink" title="出游"></a>出游</h3><p>济南陪我同游的当地朋友建议我就在这个大风景区(中间绿色一块)周围玩，这是济南旧城区，环绕的是护城河</p><p>沿着红色路线，先玩趵突泉，再去五龙潭公园，接着大明湖景区，黑虎谭，最后走到世贸逛商圈（全程下来29000步）</p><p><a href="https://imgchr.com/i/NQAR8H" target="_blank" rel="noopener"><img alt="NQAR8H.md.png" data-src="https://s1.ax1x.com/2020/06/20/NQAR8H.md.png" class="lazyload"></a></p><h4 id="趵突泉"><a href="#趵突泉" class="headerlink" title="趵突泉"></a>趵突泉</h4><p>断流的事情也会发生在“天下第一泉”，因为一周没下雨，没看到趵突泉喷涌的样子。根据济南伙伴的描述，雨后的水面是清澈的，喷涌而出的水带来了银环似的涟漪，可惜只能存在于想象中</p><p><a href="https://imgchr.com/i/NQVshD" target="_blank" rel="noopener"><img alt="NQVshD.md.jpg" data-src="https://s1.ax1x.com/2020/06/20/NQVshD.md.jpg" class="lazyload"></a><br><a href="https://imgchr.com/i/NQV69e" target="_blank" rel="noopener"><img alt="NQV69e.md.jpg" data-src="https://s1.ax1x.com/2020/06/20/NQV69e.md.jpg" class="lazyload"></a><br><a href="https://imgchr.com/i/NQVrtO" target="_blank" rel="noopener"><img alt="NQVrtO.md.jpg" data-src="https://s1.ax1x.com/2020/06/20/NQVrtO.md.jpg" class="lazyload"></a></p><p>感觉小朋友们在专门的戏水区玩的很开心，水枪biu biu biu ！！</p><p><a href="https://imgchr.com/i/NQVc1H" target="_blank" rel="noopener"><img alt="NQVc1H.md.jpg" data-src="https://s1.ax1x.com/2020/06/20/NQVc1H.md.jpg" class="lazyload"></a></p><p>诗情画意的公园风景，相比精致的苏州的人工园林，我个人认为这边依水而建更显大气</p><p><a href="https://imgchr.com/i/NQVgcd" target="_blank" rel="noopener"><img alt="NQVgcd.md.jpg" data-src="https://s1.ax1x.com/2020/06/20/NQVgcd.md.jpg" class="lazyload"></a></p><p>根据地质图，济南的泉水是从南部山区通过地下水源到达市区的趵突泉等地的</p><p><a href="https://imgchr.com/i/NQV2jA" target="_blank" rel="noopener"><img alt="NQV2jA.md.jpg" data-src="https://s1.ax1x.com/2020/06/20/NQV2jA.md.jpg" class="lazyload"></a></p><h4 id="五龙潭公园和大明湖公园"><a href="#五龙潭公园和大明湖公园" class="headerlink" title="五龙潭公园和大明湖公园"></a>五龙潭公园和大明湖公园</h4><p>这俩地方都没有收门票，好感up up ，缓解我没有看到趵突泉喷涌的郁闷</p><p><a href="https://imgchr.com/i/NQesQH" target="_blank" rel="noopener"><img alt="NQesQH.md.jpg" data-src="https://s1.ax1x.com/2020/06/20/NQesQH.md.jpg" class="lazyload"></a></p><p>大明湖的荷叶给我留下了深刻的印象，遥想当年琼瑶阿姨笔下大明湖畔的夏雨荷，应是“雨后倚伞赏荷“</p><p><a href="https://imgchr.com/i/NQeyyd" target="_blank" rel="noopener"><img alt="NQeyyd.md.jpg" data-src="https://s1.ax1x.com/2020/06/20/NQeyyd.md.jpg" class="lazyload"></a><br><a href="https://imgchr.com/i/NQe6OA" target="_blank" rel="noopener"><img alt="NQe6OA.md.jpg" data-src="https://s1.ax1x.com/2020/06/20/NQe6OA.md.jpg" class="lazyload"></a></p><p>古色生香的雨荷亭</p><p><a href="https://imgchr.com/i/NQegeI" target="_blank" rel="noopener"><img alt="NQegeI.md.jpg" data-src="https://s1.ax1x.com/2020/06/20/NQegeI.md.jpg" class="lazyload"></a></p><h4 id="宽厚里和天猫馆"><a href="#宽厚里和天猫馆" class="headerlink" title="宽厚里和天猫馆"></a>宽厚里和天猫馆</h4><p>宽厚里给我的感觉是类似于南锣鼓巷的存在，小吃很多，撸猫咖啡馆之类小众的地方需要自己去发掘</p><p>阿水——“今夜我是天选，也是唯一”……咳咳咳，走错片场了</p><p>阿水大杯茶的半糖加冰草莓果果，很8错</p><p><a href="https://imgchr.com/i/NQmm1e" target="_blank" rel="noopener"><img alt="NQmm1e.md.jpg" data-src="https://s1.ax1x.com/2020/06/20/NQmm1e.md.jpg" class="lazyload"></a></p><p>天猫生活馆，小资情调max，一个复古的网红键盘1200+，溜了</p><p><a href="https://imgchr.com/i/NQmepD" target="_blank" rel="noopener"><img alt="NQmepD.md.jpg" data-src="https://s1.ax1x.com/2020/06/20/NQmepD.md.jpg" class="lazyload"></a></p><h3 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h3><p>选了一家宽厚里商圈附近本地的鲁菜馆，试了几个菜：</p><p><strong>糖醋鲤鱼</strong>：不建议两个人吃，太大了吃不完，四人以上可以点尝尝味道，吃多了会比较腻；类比我吃过的西湖醋鱼和北京松鼠桂鱼，个人觉得皆名气大于实力</p><p><strong>煎饼</strong>：第一次吃配料品类比较多样的山东煎饼，面饼是比较厚的，可以掰开一块面饼分两块吃，有小伙伴说在天津也吃过这道菜，看来津菜和山东菜不分家。值得一提的是，馓子很松散软乎，搭配食用口感不错</p><p><a href="https://imgchr.com/i/N1BS0A" target="_blank" rel="noopener"><img alt="N1BS0A.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N1BS0A.md.jpg" class="lazyload"></a></p><p><strong>酱菜包</strong>：菜包的口感并不好，但是大小很大觉得很实惠，个人不爱吃</p><p><a href="https://imgchr.com/i/N1rfl8" target="_blank" rel="noopener"><img alt="N1rfl8.th.jpg" data-src="https://s1.ax1x.com/2020/06/21/N1rfl8.th.jpg" class="lazyload"></a></p><p><strong>九转回肠</strong>：大肠，我没点，但是是招牌菜，建议去点</p><p><strong>爆炒腰子</strong>：招牌菜，我没点，建议点</p><p>以上菜品在大部分的鲁菜餐厅都能见到，不局限于某一家</p><h3 id="网上土著建议"><a href="#网上土著建议" class="headerlink" title="网上土著建议"></a>网上土著建议</h3><p>土著发言：“作为一枚八零后的土著济南人有着不同的看法……来到我美丽泉城，首推的是早晨起来喝甜沫（济南四怪之一，甜沫不甜），吃油条；中午一块大米干饭把子肉，下午尝下油旋和茶汤（济南四怪之一，茶汤非茶），晚上必须要吃个济南烧烤，来到济南不撸串儿完全体会不到济南的市井文化。话说孟家趴蹄也就那么回事，推荐历山路东仓附近的高家扒鸡的猪蹄；草包包子吧……有兴趣可以去尝一尝，个人感觉槐荫区森林公园对过的老济南灌汤包好吃！妥妥的纯肉，韭菜馅的每个包子里一个大虾仁，童叟无欺！其实我济南好吃的东西多了去了，欢迎各位来我大济南逛吃逛吃  什么大全涮肚啊！三喜麻小啊！许家砂锅啊！炒个焖饼，弄上两瓶崂山啤酒🍺，别提这日子过的有多舒坦了👍太滋儿了！”</p><h2 id="青岛游玩"><a href="#青岛游玩" class="headerlink" title="青岛游玩"></a>青岛游玩</h2><h3 id="入住-1"><a href="#入住-1" class="headerlink" title="入住"></a>入住</h3><p>宾馆定在青岛站不远的地方（七分钟路程往北走），离劈柴院不远，名为“人源客栈”，客栈价格很便宜，80双床标间，因此环境一般，客服的态度还不错；值得一提的是，三楼和四楼的热水并不充裕，因为热水器水压不够的原因。个人建议，如果对居住环境有要求，建议预定“汉庭优选”或者“全季酒店”，我订这个就是因为足够便宜，俩人均摊一天四十元，也能满足日常的基本需求，毕竟玩累了回来睡个觉。</p><h3 id="出游-1"><a href="#出游-1" class="headerlink" title="出游"></a>出游</h3><p>查询了几个攻略和帖子，最终制定了这个路线安排，实践起来个人觉得还算可以：</p><h4 id="Day-1：海岸线游览"><a href="#Day-1：海岸线游览" class="headerlink" title="Day 1：海岸线游览"></a>Day 1：海岸线游览</h4><p>从济南抵达青岛已经是中午了，简单午餐后游玩路线如下：</p><p><strong>圣弥厄尔大教堂</strong>（网红墙）、<strong>栈桥</strong>、<strong>小鱼山公园</strong>（俯瞰）、<strong>中山公园</strong>（缆车）、<strong>八大关</strong></p><p>晚上去<strong>台东步行街</strong>吃好吃的，离中山公园不远，走路或打车（晚上回住处坐8站公交）</p><p><a href="https://imgchr.com/i/N1yuKU" target="_blank" rel="noopener"><img alt="N1yuKU.md.png" data-src="https://s1.ax1x.com/2020/06/21/N1yuKU.md.png" class="lazyload"></a></p><p>大教堂附近的建筑有一定的古典气息；</p><p><a href="https://imgchr.com/i/N16VdH" target="_blank" rel="noopener"><img alt="N16VdH.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N16VdH.md.jpg" class="lazyload"></a></p><p>去往圣弥厄尔大教堂的路上有个斜坡，拍照好的朋友可以尽情发挥，附个人丑照，以人衬景，情景交融，抒发了作者对冯唐易老的感慨qaq；</p><p><a href="https://imgchr.com/i/N16Zod" target="_blank" rel="noopener"><img alt="N16Zod.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N16Zod.md.jpg" class="lazyload"></a></p><p>教堂外，拍婚纱照的人数实在是太多啦，蔚为壮观，看的我都想结婚了，虽然我还没有女朋友~；</p><p><a href="https://imgchr.com/i/N16kLD" target="_blank" rel="noopener"><img alt="N16kLD.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N16kLD.md.jpg" class="lazyload"></a></p><p>接下来去了栈桥，来到栈桥就来到海边了；</p><p>6月16日是阴天，当躲避了太阳的人们遇到了夏天的海风，心情是十分舒畅的；</p><p><a href="https://imgchr.com/i/N16vX8" target="_blank" rel="noopener"><img alt="N16vX8.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N16vX8.md.jpg" class="lazyload"></a></p><p>沿着海岸线一直走，路过德式建筑群，走到了山上的小鱼山公园，去俯瞰青岛的海岸；</p><p>小鱼山公园的绿化做的很不错，生意盎然；</p><p><a href="https://imgchr.com/i/N1cS0g" target="_blank" rel="noopener"><img alt="N1cS0g.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N1cS0g.md.jpg" class="lazyload"></a></p><p><a href="https://imgchr.com/i/N16j6f" target="_blank" rel="noopener"><img alt="N16j6f.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N16j6f.md.jpg" class="lazyload"></a></p><p>中山公园我的小伙伴觉着没啥意思，就随便逛了逛就出来了，去了八大关；</p><p>八大关的公主楼等室内场所不让进，我们在道上逛，不自觉就去到了海边的沙滩浴场；还遇到了有远道而来的COS玩家，在海边COS，因为尊重隐私便没有拍摄她们；</p><p><a href="https://imgchr.com/i/N16znS" target="_blank" rel="noopener"><img alt="N16znS.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N16znS.md.jpg" class="lazyload"></a></p><p>天色渐晚，我们去了台东步行街；初印象，有点像成都的春熙路，北京的王府井和西单，小吃街穿插在商业街中。然而，我在寻觅小红书上的网红小吃店，不知是定位不准确的原因，绕了一大圈也没找到鲜粉道、朝鲜冷面王等店面，最后在大排档一条街吃了王姐烧烤，点了生蚝、扇贝、哈蜊、青啤原浆，排挡一条街的海鲜味道还是挺不错的，来自内陆城市的我能明显吃出来区别；青啤原浆和第三天去啤酒博物馆里喝的原浆所差无几，侧面反映味道是挺棒的；</p><h4 id="Day-2：极地海洋公园、石老人浴场"><a href="#Day-2：极地海洋公园、石老人浴场" class="headerlink" title="Day 2：极地海洋公园、石老人浴场"></a>Day 2：极地海洋公园、石老人浴场</h4><p><strong>极地海洋公园</strong>，玩半天，再沿着海岸线去<strong>石老人海水浴场，</strong>可在<strong>崂山香港东路商圈</strong>吃饭</p><p><a href="https://imgchr.com/i/N1ye2V" target="_blank" rel="noopener"><img alt="N1ye2V.md.png" data-src="https://s1.ax1x.com/2020/06/21/N1ye2V.md.png" class="lazyload"></a></p><p>从火车站附近沿着地铁坐到海洋公园；</p><p>青岛海昌的极地海洋公园是我目前去过的最好的海洋公园了，即使和我心中的完美还有差距；</p><p>学生票在飞猪上可以做到150一个人，我已经当了一年的社会游民，自然没法买学生票，买的240元的通票，极地馆+深海奇幻+欢乐剧场，5D馆暂未开放，飞猪上省20，从飞猪买的，进去直接二维码验票也很方便；</p><p>进门有牌子，可以看到，每个表演都有时间表，得卡点去看；</p><p><a href="https://imgchr.com/i/N1RdN4" target="_blank" rel="noopener"><img alt="N1RdN4.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N1RdN4.md.jpg" class="lazyload"></a></p><p>极地馆的游览示意图如下</p><p><a href="https://imgchr.com/i/N1RVjP" target="_blank" rel="noopener"><img alt="N1RVjP.jpg" data-src="https://s1.ax1x.com/2020/06/21/N1RVjP.jpg" class="lazyload"></a></p><p>极地馆是主场馆，运气不错进去就赶上了海豚和白鲸的表演</p><p>开场有灯光特效，表演过程十分精彩，训练人员专业且到位，务必要看</p><p><a href="https://imgchr.com/i/N1RaEF" target="_blank" rel="noopener"><img alt="N1RaEF.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N1RaEF.md.jpg" class="lazyload"></a></p><p><a href="https://imgchr.com/i/N1RNHU" target="_blank" rel="noopener"><img alt="N1RNHU.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N1RNHU.md.jpg" class="lazyload"></a></p><p>沿着路线一直走，看到了小企鹅</p><p><a href="https://imgchr.com/i/N88h5D" target="_blank" rel="noopener"><img alt="N88h5D.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N88h5D.md.jpg" class="lazyload"></a></p><p>瞧，海豹大哥的凝视！</p><p><a href="https://imgchr.com/i/N88gDx" target="_blank" rel="noopener"><img alt="N88gDx.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N88gDx.md.jpg" class="lazyload"></a></p><p>制作成标本的各式各样的贝壳</p><p><a href="https://imgchr.com/i/N882b6" target="_blank" rel="noopener"><img alt="N882b6.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N882b6.md.jpg" class="lazyload"></a></p><p>朦胧海底</p><p><a href="https://imgchr.com/i/N8JJ00" target="_blank" rel="noopener"><img alt="N8JJ00.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N8JJ00.md.jpg" class="lazyload"></a></p><p>小黄鱼</p><p><a href="https://imgchr.com/i/N88WVK" target="_blank" rel="noopener"><img alt="N88WVK.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N88WVK.md.jpg" class="lazyload"></a></p><p>海狮表演</p><p><a href="https://imgchr.com/i/N88fUO" target="_blank" rel="noopener"><img alt="N88fUO.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N88fUO.md.jpg" class="lazyload"></a></p><p>海洋公园内也有商店，海洋特色的商品还挺有意思的</p><p><a href="https://imgchr.com/i/N8Y9H0" target="_blank" rel="noopener"><img alt="N8Y9H0.png" data-src="https://s1.ax1x.com/2020/06/21/N8Y9H0.png" class="lazyload"></a></p><p>海洋公园坐落在岸边，出了公园沿着海岸线走风景很好，岸边的路修的特别好，一边走路一边吹海风的滋味是很好的，可惜那天下了小雨</p><p>海岸线上的景色</p><p><a href="https://imgchr.com/i/N8JbAf" target="_blank" rel="noopener"><img alt="N8JbAf.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N8JbAf.md.jpg" class="lazyload"></a></p><p>一座富有人文关怀的雕像，致敬一位奉献自己救助别人的小天使</p><p><a href="https://imgchr.com/i/N8JTBt" target="_blank" rel="noopener"><img alt="N8JTBt.md.jpg" data-src="https://s1.ax1x.com/2020/06/21/N8JTBt.md.jpg" class="lazyload"></a></p><p>石老人浴场的海岸，个人觉得是市区能到达的最好的海水浴场，是我理想中沙滩的样子，海天一色，美不胜收</p><p><a href="https://s1.ax1x.com/2020/06/21/N8J7HP.jpg" data-fancybox="group" data-caption="N8J7HP.jpg" class="fancybox"><img alt="N8J7HP.jpg" title="N8J7HP.jpg" data-src="https://s1.ax1x.com/2020/06/21/N8J7HP.jpg" class="lazyload"></a></p><p><a href="https://s1.ax1x.com/2020/06/21/N8JqN8.jpg" data-fancybox="group" data-caption="N8JqN8.jpg" class="fancybox"><img alt="N8JqN8.jpg" title="N8JqN8.jpg" data-src="https://s1.ax1x.com/2020/06/21/N8JqN8.jpg" class="lazyload"></a></p><p>有青岛本地人士推荐去老胶南，乘青西线过去，说那里有最好的沙滩，我还没有试过</p><p>在附近的崂山香港东路商圈吃了点饭，在海滩漫步</p><p>海滩附近有家网红书店，透明玻璃装饰可以进去打卡</p><h4 id="Day3：啤酒博物馆、燕儿岛山公园、奥帆中心"><a href="#Day3：啤酒博物馆、燕儿岛山公园、奥帆中心" class="headerlink" title="Day3：啤酒博物馆、燕儿岛山公园、奥帆中心"></a>Day3：<strong>啤酒博物馆</strong>、<strong>燕儿岛山公园</strong>、<strong>奥帆中心</strong></h4><p>啤酒博物馆绝对是去了很值的一个地方，了解青岛最富有盛名的啤酒文化</p><p>啤酒博物馆分为A区和B区，门票建议买E票，99元，可以在出口餐厅喝到六款特色啤酒</p><p>A馆主要介绍青岛啤酒的历史</p><h2 id="总花费"><a href="#总花费" class="headerlink" title="总花费"></a>总花费</h2><h2 id="旅途总结"><a href="#旅途总结" class="headerlink" title="旅途总结"></a>旅途总结</h2><h2 id="攻略链接"><a href="#攻略链接" class="headerlink" title="攻略链接"></a>攻略链接</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总行程安排&quot;&gt;&lt;a href=&quot;#总行程安排&quot; class=&quot;headerlink&quot; title=&quot;总行程安排&quot;&gt;&lt;/a&gt;总行程安排&lt;/h2&gt;&lt;p&gt;济南玩一天（15中午-16号上午）&lt;/p&gt;
&lt;p&gt;青岛玩三天（16中午-19号凌晨）&lt;/p&gt;
&lt;h2 id=&quot;济南游
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>jupyter notebook安装失败解决办法</title>
    <link href="http://yoursite.com/2020/06/23/jupyter%20notebook%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2020/06/23/jupyter%20notebook%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2020-06-23T04:55:24.177Z</published>
    <updated>2020-06-12T03:17:20.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>学习“同济子豪兄”的python课程，涉及到了第三方库文件的安装，安装jupyter notebook时候遇到了问题</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install juypter notebook</span><br></pre></td></tr></table></figure></div><h2 id="错误表现"><a href="#错误表现" class="headerlink" title="错误表现"></a>错误表现</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collecting pywinpty&gt;&#x3D;0.5; os_name &#x3D;&#x3D; &quot;nt&quot; (from terminado&gt;&#x3D;0.8.1-&gt;notebook-&gt;jupyter)</span><br><span class="line">  Using cached pywinpty-0.5.1.tar.gz</span><br></pre></td></tr></table></figure></div><p>卡顿一段时间，出现大量的报错</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 pip3 install --upgrade setuptools 更新setuptools</span><br></pre></td></tr></table></figure></div><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/lyxuefeng/article/details/79454242?utm_source=blogxgwz7" target="_blank" rel="noopener">参考文章</a></p><p>个人采用方法二直接解决问题，没有用方法一</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;学习“同济子豪兄”的python课程，涉及到了第三方库文件的安装，安装jupyter notebook时候遇到了问题&lt;/p&gt;
&lt;div cl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Eigen——将矩阵引入C++</title>
    <link href="http://yoursite.com/2020/06/23/Eigen%E2%80%94%E2%80%94%E5%B0%86%E7%9F%A9%E9%98%B5%E5%BC%95%E5%85%A5C++/"/>
    <id>http://yoursite.com/2020/06/23/Eigen%E2%80%94%E2%80%94%E5%B0%86%E7%9F%A9%E9%98%B5%E5%BC%95%E5%85%A5C++/</id>
    <published>2020-06-23T04:55:24.175Z</published>
    <updated>2020-06-22T01:49:39.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install libeigen3-dev</span><br></pre></td></tr></table></figure></div><h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>Eigen 头文件的默认位置在“/usr/include/eigen3/” 中。如果你不确定，可以输入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo updatedb</span><br><span class="line">locate eigen3</span><br></pre></td></tr></table></figure></div><p>来查找位置。相比于其他库，Eigen 特殊之处在于，它是一个纯用头文件搭建起来的库（这非常神奇！）。这意味着你只能找到它的头文件，而没有.so 或.a 那样的二进制文件。我们在使用时，只需引入Eigen 的头文件即可，不需要链接它的库文件（因为它没有库文件）。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>下面我们写一段代码，来实际练习一下Eigen 的使用：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="comment">// Eigen 部分</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="comment">// 稠密矩阵的代数运算（逆，特征值等）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATRIX_SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************</span></span><br><span class="line"><span class="comment">* 本程序演示了 Eigen 基本类型的使用</span></span><br><span class="line"><span class="comment">****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Eigen 中所有向量和矩阵都是Eigen::Matrix，它是一个模板类。它的前三个参数为：数据类型，行，列</span></span><br><span class="line">    <span class="comment">// 声明一个2*3的float矩阵</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">3</span>&gt; matrix_23;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时，Eigen 通过 typedef 提供了许多内置类型，不过底层仍是Eigen::Matrix</span></span><br><span class="line">    <span class="comment">// 例如 Vector3d 实质上是 Eigen::Matrix&lt;double, 3, 1&gt;，即三维向量</span></span><br><span class="line">    Eigen::Vector3d v_3d;</span><br><span class="line"><span class="comment">// 这是一样的</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">float</span>,<span class="number">3</span>,<span class="number">1</span>&gt; vd_3d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Matrix3d 实质上是 Eigen::Matrix&lt;double, 3, 3&gt;</span></span><br><span class="line">    Eigen::Matrix3d matrix_33 = Eigen::Matrix3d::Zero(); <span class="comment">//初始化为零</span></span><br><span class="line">    <span class="comment">// 如果不确定矩阵大小，可以使用动态大小的矩阵</span></span><br><span class="line">    Eigen::Matrix&lt; <span class="keyword">double</span>, Eigen::Dynamic, Eigen::Dynamic &gt; matrix_dynamic;</span><br><span class="line">    <span class="comment">// 更简单的</span></span><br><span class="line">    Eigen::MatrixXd matrix_x;</span><br><span class="line">    <span class="comment">// 这种类型还有很多，我们不一一列举</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是对Eigen阵的操作</span></span><br><span class="line">    <span class="comment">// 输入数据（初始化）</span></span><br><span class="line">    matrix_23 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; matrix_23 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用()访问矩阵中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;matrix_23(i,j)&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵和向量相乘（实际上仍是矩阵和矩阵）</span></span><br><span class="line">    v_3d &lt;&lt; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>;</span><br><span class="line">    vd_3d &lt;&lt; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 但是在Eigen里你不能混合两种不同类型的矩阵，像这样是错的</span></span><br><span class="line">    <span class="comment">// Eigen::Matrix&lt;double, 2, 1&gt; result_wrong_type = matrix_23 * v_3d;</span></span><br><span class="line">    <span class="comment">// 应该显式转换</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">1</span>&gt; result = matrix_23.cast&lt;<span class="keyword">double</span>&gt;() * v_3d;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">1</span>&gt; result2 = matrix_23 * vd_3d;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样你不能搞错矩阵的维度</span></span><br><span class="line">    <span class="comment">// 试着取消下面的注释，看看Eigen会报什么错</span></span><br><span class="line">    <span class="comment">// Eigen::Matrix&lt;double, 2, 3&gt; result_wrong_dimension = matrix_23.cast&lt;double&gt;() * v_3d;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些矩阵运算</span></span><br><span class="line">    <span class="comment">// 四则运算就不演示了，直接用+-*/即可。</span></span><br><span class="line">    matrix_33 = Eigen::Matrix3d::Random();      <span class="comment">// 随机数矩阵</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; matrix_33 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; matrix_33.transpose() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">// 转置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; matrix_33.sum() &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">// 各元素和</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; matrix_33.trace() &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">// 迹</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">10</span>*matrix_33 &lt;&lt; <span class="built_in">endl</span>;               <span class="comment">// 数乘</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; matrix_33.inverse() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 逆</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; matrix_33.determinant() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 行列式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特征值</span></span><br><span class="line">    <span class="comment">// 实对称矩阵可以保证对角化成功</span></span><br><span class="line">    <span class="function">Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix3d&gt; <span class="title">eigen_solver</span> <span class="params">( matrix_33.transpose()*matrix_33 )</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Eigen values = "</span> &lt;&lt; eigen_solver.eigenvalues() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Eigen vectors = "</span> &lt;&lt; eigen_solver.eigenvectors() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解方程</span></span><br><span class="line">    <span class="comment">// 我们求解 matrix_NN * x = v_Nd 这个方程</span></span><br><span class="line">    <span class="comment">// N的大小在前边的宏里定义，它由随机数生成</span></span><br><span class="line">    <span class="comment">// 直接求逆自然是最直接的，但是求逆运算量大</span></span><br><span class="line"></span><br><span class="line">    Eigen::Matrix&lt; <span class="keyword">double</span>, MATRIX_SIZE, MATRIX_SIZE &gt; matrix_NN;</span><br><span class="line">    matrix_NN = Eigen::MatrixXd::Random( MATRIX_SIZE, MATRIX_SIZE );</span><br><span class="line">    Eigen::Matrix&lt; <span class="keyword">double</span>, MATRIX_SIZE,  <span class="number">1</span>&gt; v_Nd;</span><br><span class="line">    v_Nd = Eigen::MatrixXd::Random( MATRIX_SIZE,<span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">clock_t</span> time_stt = clock(); <span class="comment">// 计时</span></span><br><span class="line">    <span class="comment">// 直接求逆</span></span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>,MATRIX_SIZE,<span class="number">1</span>&gt; x = matrix_NN.inverse()*v_Nd;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"time use in normal inverse is "</span> &lt;&lt; <span class="number">1000</span>* (clock() - time_stt)/(<span class="keyword">double</span>)CLOCKS_PER_SEC &lt;&lt; <span class="string">"ms"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 通常用矩阵分解来求，例如QR分解，速度会快很多</span></span><br><span class="line">    time_stt = clock();</span><br><span class="line">    x = matrix_NN.colPivHouseholderQr().solve(v_Nd);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"time use in Qr decomposition is "</span> &lt;&lt;<span class="number">1000</span>*  (clock() - time_stt)/(<span class="keyword">double</span>)CLOCKS_PER_SEC &lt;&lt;<span class="string">"ms"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><a href="https://imgchr.com/i/N8q08x" target="_blank" rel="noopener"><img alt="N8q08x.png" data-src="https://s1.ax1x.com/2020/06/22/N8q08x.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;div class=&quot;code-area-wrap&quot;&gt;&lt;div class=&quot;highlight-tools&quot;&gt;&lt;i class=&quot;fa fa-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>xshell突然无法连接ubuntu的经历</title>
    <link href="http://yoursite.com/2020/03/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1xshell%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5ubuntu%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2020/03/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1xshell%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5ubuntu%E7%BB%8F%E5%8E%86/</id>
    <published>2020-03-26T08:20:05.000Z</published>
    <updated>2020-03-26T08:37:48.139Z</updated>
    
    <content type="html"><![CDATA[<p>2020年3月26日，平静的下午，屋外乌云密布，屋内的我起床开始码字。</p><p>解开电脑锁屏发现xshell和往常一样，长时间不使用断开了，于是我在xhsell的设置里添加了每25秒自动重连，准备一劳永逸解决以后会遇到的这种问题。</p><p>然而，事情并不像我想的这么简单，xhell突然无法重连，明明什么配置都没有改变。</p><p>我仔细的想了想，开始搜索“xshell无法连接ubuntu”“ubuntu突然连不上了”收效甚微，接着在不断的翻阅无功而返后，开始尝试精准的定位问题。</p><hr><p>首先，查询ssh的服务，看ssh服务是否正常开启，发现是开启的，并且监听着22号端口。</p><p>其次，ubuntu开始 ping 主机的地址，发现是可以ping通的；再用主机ping ubuntu 的地址，发现ping不通，于是锁定了问题所在。</p><p><a href="https://s1.ax1x.com/2020/03/26/GSzKiR.png" data-fancybox="group" data-caption="GSzKiR.png" class="fancybox"><img alt="GSzKiR.png" title="GSzKiR.png" data-src="https://s1.ax1x.com/2020/03/26/GSzKiR.png" class="lazyload"></a></p><p>情况一：虚拟机防火墙阻止了ping通</p><p>解决办法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure></div><p>情况二：vnet8无线网卡被关闭</p><p>解决办法：打开vnet8无线网卡</p><hr><p>情况一尝试关闭防火墙后，无效；情况二，发现vnet8是开启的。这就很纳闷了，为什么会出现这种情况呢？</p><p>思考再三，决定手动重启一下vnet8网络，试一试</p><p><a href="https://s1.ax1x.com/2020/03/26/GSztdH.png" data-fancybox="group" data-caption="GSztdH.png" class="fancybox"><img alt="GSztdH.png" title="GSztdH.png" data-src="https://s1.ax1x.com/2020/03/26/GSztdH.png" class="lazyload"></a></p><p>很奇妙，xhsell终于可以连接成功了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年3月26日，平静的下午，屋外乌云密布，屋内的我起床开始码字。&lt;/p&gt;
&lt;p&gt;解开电脑锁屏发现xshell和往常一样，长时间不使用断开了，于是我在xhsell的设置里添加了每25秒自动重连，准备一劳永逸解决以后会遇到的这种问题。&lt;/p&gt;
&lt;p&gt;然而，事情并不像我想的
      
    
    </summary>
    
    
    
      <category term="bug调试" scheme="http://yoursite.com/tags/bug%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode初级算法——代码笔记整理</title>
    <link href="http://yoursite.com/2020/02/12/leetcode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%20%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/12/leetcode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%20%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</id>
    <published>2020-02-12T10:56:01.000Z</published>
    <updated>2020-02-15T01:50:48.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode初级算法——代码笔记整理"><a href="#leetcode初级算法——代码笔记整理" class="headerlink" title="leetcode初级算法——代码笔记整理"></a>leetcode初级算法——代码笔记整理</h1><p>网址：<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/" target="_blank" rel="noopener">https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/</a></p><p>本文对应的leetcode题目采取的写法为：&lt;题号.题目名称&gt;     例如：26.删除数组中的重复项</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="26-删除数组中的重复项"><a href="#26-删除数组中的重复项" class="headerlink" title="26.删除数组中的重复项"></a>26.删除数组中的重复项</h3><p>双指针法，j前i后，初始时i=0.j=1；当a[i]与a[j]相同，j++；</p><p>a[j]与a[i]不同，i追上j的位置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int removeDuplicates(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums.size() &lt;&#x3D; 1)</span><br><span class="line">            return nums.size();</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 1; j &lt; nums.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] !&#x3D; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                nums[i] &#x3D; nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i + 1; </span><br><span class="line">        &#x2F;&#x2F;return nums.size();&#x2F;&#x2F;error 数组的后半部分没清理赶紧，因此需要返回i+1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="122-买卖股票的最佳时机"><a href="#122-买卖股票的最佳时机" class="headerlink" title="122.买卖股票的最佳时机"></a>122.买卖股票的最佳时机</h3><p>采取贪心算法，只要第二天价格高就卖出；</p><p>注意初始数组为空的情况</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) </span><br><span class="line">    &#123;</span><br><span class="line">      int profit &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i + 1 &lt; prices.size(); ++i) </span><br><span class="line">        &#123;profit +&#x3D; max(prices[i + 1] - prices[i], 0);&#125;</span><br><span class="line">        return profit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189.旋转数组"></a>189.旋转数组</h3><p>旋转数组的低效写法是末尾出元素，开头入元素，舍弃；</p><p>高效写法的实质就是三次原地逆置数组，注意k值取模</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void rotate(vector&lt;int&gt; &amp;nums, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        reverse(nums.begin(), nums.end() - k % nums.size()); </span><br><span class="line">        reverse(nums.end() - k % nums.size(), nums.end());</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h3><p>存入set，用大小比较来巧妙解决是否有重复元素的元素；</p><p>注意每个分支if else后面都要有返回值，否则编译不通过</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        set&lt;int&gt;s1(nums.begin(),nums.end());</span><br><span class="line">        return nums.size()!&#x3D;s1.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h3><p>遍历+异或 ，位操作无比高效</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       int result&#x3D;0;</span><br><span class="line">       for(auto elm:nums)</span><br><span class="line">       &#123;</span><br><span class="line">           result^&#x3D;elm;</span><br><span class="line">       &#125;</span><br><span class="line">       return result; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="350-两个数组的交集"><a href="#350-两个数组的交集" class="headerlink" title="350.两个数组的交集"></a>350.两个数组的交集</h3><p>运用哈希表来完成，一个数组负责加，一个数组负责减</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">       vector&lt;int&gt;rec;</span><br><span class="line">       unordered_map&lt;int,int&gt;map;</span><br><span class="line">       for(int i &#x3D;0;i&lt;nums1.size();++i)</span><br><span class="line">           map[nums1[i]]+&#x3D;1; &#x2F;&#x2F;记录次数</span><br><span class="line">       for(int i &#x3D;0;i&lt;nums2.size();++i)&#123; &#x2F;&#x2F;map先记录A的，再比较B的，核心在于匹配一次之后权值-1，防止重复元素的干扰</span><br><span class="line">          if(map[nums2[i]]&gt;0)&#x2F;&#x2F;两个数组有交集</span><br><span class="line">          &#123;</span><br><span class="line">              rec.push_back(nums2[i]);</span><br><span class="line">              map[nums2[i]]-&#x3D;1;  &#x2F;&#x2F;防止同一个数组中的重复元素的困扰</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return rec;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="66-加一"><a href="#66-加一" class="headerlink" title="66.加一"></a>66.加一</h3><p>三种情况：</p><p>末尾无9，例如2548，直接++</p><p>末尾若干个9,例如299，9全变成0，第一个非9的数++</p><p>全部都是9，例如999，9全变成0，末尾添0，首位变成1</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; digits.size() - 1; i &gt;&#x3D; 0; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (digits[i] &#x3D;&#x3D; 9)</span><br><span class="line">                digits[i] &#x3D; 0;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                return digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits.push_back(0);</span><br><span class="line">        digits[0] &#x3D; 1;</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h3><p>遍历的时候，count记录零的个数，就地向前移动；</p><p>遍历结束之后，尾部count个元素令等于0；</p><p>以此实现原地改造数组</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void moveZeroes(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (size_t i &#x3D; 0; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] !&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i - count] &#x3D; nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (size_t i &#x3D; nums.size() - 1; i &gt; (nums.size() - count-1); --i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">       unordered_map&lt;int,int&gt;result;</span><br><span class="line">       vector&lt;int&gt;vec1;</span><br><span class="line">       for(int i&#x3D;0;i&lt;nums.size();++i)</span><br><span class="line">       &#123;</span><br><span class="line">           int need&#x3D;target-nums[i];</span><br><span class="line">           auto find1&#x3D;result.find(need);</span><br><span class="line">           if(find1!&#x3D;result.end())&#x2F;&#x2F;could find</span><br><span class="line">           &#123;</span><br><span class="line">               vec1.push_back(i);</span><br><span class="line">               vec1.push_back(find1-&gt;second);</span><br><span class="line">               break;</span><br><span class="line">           &#125;&#x2F;&#x2F;could not find</span><br><span class="line">           else result[nums[i]]&#x3D;i;&#x2F;&#x2F;insert 2,turn to 7,could find</span><br><span class="line">       &#125;</span><br><span class="line">       return vec1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36.有效的数独"></a>36.有效的数独</h3><p>本题颇具难度，需要花点时间思考；</p><p>本解法仍待提升，希望采取哈希的写法提升效率</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int getSquare(int i,int j)</span><br><span class="line">   &#123;</span><br><span class="line">       i&#x3D;i&#x2F;3;</span><br><span class="line">       j&#x3D;j&#x2F;3;</span><br><span class="line">       return i+3*j;</span><br><span class="line">   &#125;</span><br><span class="line">   bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">       vector&lt;vector&lt;int&gt;&gt; line(9, vector&lt;int&gt;(10, 0));&#x2F;&#x2F;共9行，每行10个数字对应0~9</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; row(9, vector&lt;int&gt;(10, 0));&#x2F;&#x2F;9列</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; square(9, vector&lt;int&gt;(10, 0));&#x2F;&#x2F;9个单元格</span><br><span class="line">       for(int i&#x3D;0;i&lt;9;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           for(int j&#x3D;0;j&lt;9;++j)</span><br><span class="line">           &#123;</span><br><span class="line">               if(board[i][j]&#x3D;&#x3D;&#39;.&#39;)</span><br><span class="line">               &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               int num&#x3D;board[i][j]-&#39;0&#39;;</span><br><span class="line">               if(line[i][num]&#x3D;&#x3D;0) &#123;++line[i][num];&#125;</span><br><span class="line">               else return false;</span><br><span class="line">               if(row[j][num]&#x3D;&#x3D;0) ++row[j][num];</span><br><span class="line">               else return false;</span><br><span class="line">               if(square[getSquare(i,j)][num]&#x3D;&#x3D;0)  ++square[getSquare(i,j)][num];</span><br><span class="line">               else return false;</span><br><span class="line">           &#125;   </span><br><span class="line">       &#125;</span><br><span class="line">           return true;</span><br><span class="line">   &#125;&#x2F;&#x2F;没有用哈希，因此效率不够好</span><br></pre></td></tr></table></figure></div><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h3><p>实质是原地旋转90度，<strong>仔细观察规律</strong><br>1.沿主对⻆角线所有元素交换<br>2.沿着垂直中轴线⽅方向所有元素交换</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">for(int i &#x3D; 0; i &lt; matrix.size(); i++)</span><br><span class="line">for(int j &#x3D; 0; j &lt;&#x3D; i; j++)</span><br><span class="line">swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">for(int i &#x3D; 0, j &#x3D; matrix.size() - 1; i &lt; j; i++, j--)</span><br><span class="line">for(int k &#x3D; 0; k &lt; matrix.size(); k++)</span><br><span class="line">swap(matrix[k][i], matrix[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>遍历时引入temp交换即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void reverseString(vector&lt;char&gt;&amp; s) &#123;</span><br><span class="line">        char temp;</span><br><span class="line">        int size &#x3D; s.size();</span><br><span class="line">        for(int i&#x3D;0;i&lt;size&#x2F;2;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp&#x3D;s[i];</span><br><span class="line">            s[i]&#x3D;s[size-1-i];</span><br><span class="line">            s[size-1-i]&#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h3><p>原生反转其实很简单，三句话就可实现</p><p><strong>在防溢出这里的写法是值得学习的</strong></p><pre><code>//INT_MAX = 2^31-1=2147483647；//INT_MIN= -2^31=-2147483648；</code></pre><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int reverse(int x) &#123;</span><br><span class="line">       int ret&#x3D;0;</span><br><span class="line">       while(x!&#x3D;0)</span><br><span class="line">       &#123;</span><br><span class="line">           int pop&#x3D;x%10;</span><br><span class="line">           x&#x2F;&#x3D;10;</span><br><span class="line">           if(ret&gt;INT_MAX&#x2F;10||(ret&#x3D;&#x3D;INT_MAX&#x2F;10&amp;&amp;pop&gt;7))return 0;</span><br><span class="line">           if(ret&lt;INT_MIN&#x2F;10||(ret&#x3D;&#x3D;INT_MIN&#x2F;10&amp;&amp;pop&lt;-8))return 0;</span><br><span class="line">           ret&#x3D;ret*10+pop;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387.字符串中的第一个唯一字符"></a>387.字符串中的第一个唯一字符</h3><p>两次遍历，遍历的精髓就在以数组下标i为变化量，两次都是以i来遍历，因为返回值是数组下标</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int firstUniqChar(string s) &#123;</span><br><span class="line">       map&lt;char,int&gt;mp1;</span><br><span class="line">       int length&#x3D;s.size();</span><br><span class="line">       for(int i&#x3D;0;i&lt;length;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           ++mp1[s[i]];</span><br><span class="line">       &#125;</span><br><span class="line">       for(int i&#x3D;0;i&lt;length;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           if(mp1[s[i]]&#x3D;&#x3D;1) return i;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;&#x2F;&#x2F;必不可少</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p>两个字符串，一个负责“加”，一个负责“减”</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if(s.size() !&#x3D; t.size())</span><br><span class="line">           return false;</span><br><span class="line">       int *alpha &#x3D; new int[26](); &#x2F;&#x2F;只包括小写字母</span><br><span class="line">       for(int i &#x3D; 0; i&lt; s.size(); i++) &#123;</span><br><span class="line">           alpha[s[i] - &#39;a&#39;] ++;</span><br><span class="line">           alpha[t[i] - &#39;a&#39;] --;</span><br><span class="line">       &#125; &#x2F;&#x2F;如果数目完全相同，则alpha所有位值都是0，一加一减的方法很巧妙</span><br><span class="line">       for(int i&#x3D;0;i&lt;26;i++)&#123;</span><br><span class="line">           if(alpha[i] !&#x3D; 0)</span><br><span class="line">           &#123;return false;&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="125-验证回文字符串"><a href="#125-验证回文字符串" class="headerlink" title="125.验证回文字符串"></a>125.验证回文字符串</h3><p>回文的特性决定了双指针的写法，一个从前往后一个从后往前</p><p>while内部的用法很细节，isalnum tolower很细节，把不纳入判断的元素过滤</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool isPalindrome(string s) &#123;</span><br><span class="line">       &#x2F;&#x2F; 双指针</span><br><span class="line">       if(s.size() &lt;&#x3D; 1) return true; &#x2F;&#x2F;空字符串返回true</span><br><span class="line">       int i &#x3D; 0, j &#x3D; s.size() - 1; &#x2F;&#x2F;一个头一个尾</span><br><span class="line">       while(i &lt; j)&#123;</span><br><span class="line">           while(i &lt; j &amp;&amp; !isalnum(s[i])) </span><br><span class="line">           &#x2F;&#x2F; 如果是合格字符，while（0）直接跳过，最后到了比对环节；如果是非合格字符，如逗号，while（1）执行i++，跳过了这个非字符元素，</span><br><span class="line">           &#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           while(i &lt; j &amp;&amp; !isalnum(s[j]))</span><br><span class="line">           &#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           if(tolower(s[i++]) !&#x3D; tolower(s[j--])) </span><br><span class="line">           &#x2F;&#x2F;统一转换成小写字母再比较，比对环节一旦出问题，直接return false；</span><br><span class="line">               return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8.字符串转换整数 (atoi)"></a>8.字符串转换整数 (atoi)</h3><p>这道题目细节之处很多，<strong>代码值得仔细研究</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int myAtoi(string str) &#123;</span><br><span class="line">       int ret&#x3D;0;</span><br><span class="line">       int i&#x3D;0;</span><br><span class="line">       int flag&#x3D;1;</span><br><span class="line">       while(str[i]&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">       &#123;</span><br><span class="line">           ++i;</span><br><span class="line">       &#125;</span><br><span class="line">       if(str[i]&#x3D;&#x3D;&#39;-&#39;)</span><br><span class="line">       &#123;</span><br><span class="line">           flag&#x3D;-1;</span><br><span class="line">       &#125;</span><br><span class="line">       if(str[i]&#x3D;&#x3D;&#39;+&#39;||str[i]&#x3D;&#x3D;&#39;-&#39;)</span><br><span class="line">       &#123;</span><br><span class="line">           ++i;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;数字处理这里十分细节</span><br><span class="line">       while(i&lt;str.size()&amp;&amp;isdigit(str[i]))</span><br><span class="line">       &#123;</span><br><span class="line">           int r&#x3D;str[i]-&#39;0&#39;;&#x2F;&#x2F;这里将字符数字转成实际数字，减去&#39;0&#39;</span><br><span class="line">           if(ret&gt;INT_MAX&#x2F;10||(ret&#x3D;&#x3D;INT_MAX&#x2F;10&amp;&amp;r&gt;7))</span><br><span class="line">           &#123;</span><br><span class="line">               return flag&gt;0?INT_MAX:INT_MIN;</span><br><span class="line">           &#125;</span><br><span class="line">           ret&#x3D;ret*10+r;</span><br><span class="line">           ++i;</span><br><span class="line">       &#125;</span><br><span class="line">       return flag&gt;0?ret:-ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="28-实现strstr"><a href="#28-实现strstr" class="headerlink" title="28.实现strstr()"></a>28.实现strstr()</h3><p>最暴力的解法是粗暴回退法，KMP是其改进</p><p><strong>对于solution里的KMP和dp KMP还需要钻研</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; getnext(string str)</span><br><span class="line">        &#123;</span><br><span class="line">            int len&#x3D;str.size();</span><br><span class="line">            vector&lt;int&gt; next;</span><br><span class="line">            next.push_back(-1);</span><br><span class="line">            int j&#x3D;0,k&#x3D;-1;</span><br><span class="line">            while(j&lt;len-1)</span><br><span class="line">            &#123;</span><br><span class="line">                if(k&#x3D;&#x3D;-1||str[j]&#x3D;&#x3D;str[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    k++;</span><br><span class="line">                    if(str[j]!&#x3D;str[k])</span><br><span class="line">                        next.push_back(k);</span><br><span class="line">                    else</span><br><span class="line">                        next.push_back(next[k]);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    k&#x3D;next[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    int strStr(string haystack, string needle) &#123;</span><br><span class="line">        if(needle.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        int j&#x3D;0;</span><br><span class="line">        int len1&#x3D;haystack.size();</span><br><span class="line">        int len2&#x3D;needle.size();</span><br><span class="line">        vector&lt;int&gt; next;</span><br><span class="line">        next&#x3D;getnext(needle);</span><br><span class="line">        while((i&lt;len1)&amp;&amp;(j&lt;len2))</span><br><span class="line">        &#123;</span><br><span class="line">            if((j&#x3D;&#x3D;-1)||(haystack[i]&#x3D;&#x3D;needle[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                j&#x3D;next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j&#x3D;&#x3D;len2)</span><br><span class="line">            return i-j;</span><br><span class="line">        </span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38.外观数列"></a>38.外观数列</h3><p>递归和出口、count计数、字符串拼接</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">string countAndSay(int n) &#123;</span><br><span class="line">       if(n&#x3D;&#x3D;1) return &quot;1&quot;;</span><br><span class="line">       string strlast&#x3D;countAndSay(n-1);</span><br><span class="line">       int count&#x3D;1;</span><br><span class="line">       string ret;</span><br><span class="line">       for(int i&#x3D;0;i&lt;strlast.size();++i)</span><br><span class="line">       &#123;</span><br><span class="line">           if(strlast[i]&#x3D;&#x3D;strlast[i+1])</span><br><span class="line">           &#123;</span><br><span class="line">               ++count;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               if(strlast[i]!&#x3D;strlast[i+1])</span><br><span class="line">               &#123;</span><br><span class="line">                   ret+&#x3D;to_string(count)+strlast[i];</span><br><span class="line">                   count&#x3D;1;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="14-最长公共前缀匹配"><a href="#14-最长公共前缀匹配" class="headerlink" title="14.最长公共前缀匹配"></a>14.最长公共前缀匹配</h3><p>先遍历，找到最短的字符串；再遍历最短字符串的每一个元素，如果和其他的相同位置元素不匹配，直接return false；全部匹配返回true；</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">       string ans &#x3D; &quot;&quot;;</span><br><span class="line">       if(strs.empty())    return ans; &#x2F;&#x2F;输入为空，输出空ans</span><br><span class="line">       int arr &#x3D; strs.size();</span><br><span class="line">       string min &#x3D; strs[0];</span><br><span class="line">       for(int i &#x3D; 1; i &lt; arr; ++ i) &#x2F;&#x2F;找到最短字符串</span><br><span class="line">       &#123;</span><br><span class="line">           if(strs[i].size() &lt; min.size())</span><br><span class="line">               min &#x3D; strs[i];</span><br><span class="line">       &#125;</span><br><span class="line">       for(int j &#x3D; 0; j &lt; min.size(); ++ j) </span><br><span class="line">       &#x2F;&#x2F;从第一个字符开始对比，若都一样，ans加上该字符，若不一样，返回答案；</span><br><span class="line">       &#123;</span><br><span class="line">           for(int m &#x3D; 0; m &lt; arr; ++m)</span><br><span class="line">           &#123;</span><br><span class="line">               if(min[j] !&#x3D; strs[m][j])</span><br><span class="line">                   return ans; &#x2F;&#x2F;错误就直接返回</span><br><span class="line">           &#125;</span><br><span class="line">           ans &#x3D; ans + min[j]; &#x2F;&#x2F;全部对上了就把内容加上</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h3><p>很简单，略过，不断链即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void deleteNode(ListNode* node) &#123; &#x2F;&#x2F;已经定义好了这个ListNode结构体，并且把要删除的结点传了进来</span><br><span class="line">       *node&#x3D;*(node-&gt;next);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p>双指针法是链表中常用的技术手段</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">       &#x2F;&#x2F;如果用两次遍历法，也应该先创建个头结点</span><br><span class="line">       ListNode* former&#x3D;new ListNode(0);</span><br><span class="line">       former-&gt;next&#x3D;head;&#x2F;&#x2F;这次尝试双指针法</span><br><span class="line">       ListNode * p&#x3D;former;</span><br><span class="line">       ListNode * q&#x3D;former;&#x2F;&#x2F;这里都要从former开始,避免了初始1个元素就删除这一个元素的情况</span><br><span class="line">       int count&#x3D;0;</span><br><span class="line">       while(count&lt;n)</span><br><span class="line">       &#123;</span><br><span class="line">           ++count;</span><br><span class="line">           q&#x3D;q-&gt;next;</span><br><span class="line">       &#125; &#x2F;&#x2F;先把p q偏移好一定的位置</span><br><span class="line">       while(q-&gt;next!&#x3D;NULL)</span><br><span class="line">       &#123;</span><br><span class="line">           q&#x3D;q-&gt;next;</span><br><span class="line">           p&#x3D;p-&gt;next;</span><br><span class="line">       &#125;&#x2F;&#x2F;p q 一起右移，直到q移到最后一个元素位置</span><br><span class="line">       ListNode * del&#x3D;p-&gt;next;&#x2F;&#x2F;写这步的目的是del删除节点，回收资源。否则直接双next写法</span><br><span class="line">       p-&gt;next&#x3D;del-&gt;next;</span><br><span class="line">       delete del;</span><br><span class="line">       ListNode * ret&#x3D;former-&gt;next;</span><br><span class="line">       delete former;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p>递归的写法，如图</p><p><a href="https://s2.ax1x.com/2020/02/12/1HsnPK.gif" data-fancybox="group" data-caption="1HsnPK.gif" class="fancybox"><img alt="1HsnPK.gif" title="1HsnPK.gif" data-src="https://s2.ax1x.com/2020/02/12/1HsnPK.gif" class="lazyload"></a></p><p>一次遍历，边遍历边修改的写法是最好 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">       if(head&#x3D;&#x3D;nullptr)</span><br><span class="line">       &#123;</span><br><span class="line">           return head;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode * first &#x3D; head;</span><br><span class="line">       ListNode * target &#x3D; first-&gt;next;</span><br><span class="line">       while(target!&#x3D;nullptr)</span><br><span class="line">       &#123;</span><br><span class="line">           first-&gt;next&#x3D;target-&gt;next;</span><br><span class="line">           ListNode * temp &#x3D; target-&gt;next;</span><br><span class="line">           target-&gt;next&#x3D;head;</span><br><span class="line">           head&#x3D;target;</span><br><span class="line">           target&#x3D;temp;</span><br><span class="line">       &#125;</span><br><span class="line">       return head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h3><p><strong>精髓思想</strong>是，不改变原有的两个链表的本来指向，新定义一个指针，规定其指向，不断把满足要求的结点添加到其后面</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">       ListNode * former &#x3D; new ListNode(-1);</span><br><span class="line">       ListNode * curnode &#x3D; former;</span><br><span class="line">       while(l1!&#x3D;nullptr&amp;&amp;l2!&#x3D;nullptr)</span><br><span class="line">       &#123;</span><br><span class="line">           if(l1-&gt;val&gt;l2-&gt;val)</span><br><span class="line">           &#123;</span><br><span class="line">               curnode-&gt;next&#x3D;l2;</span><br><span class="line">               l2&#x3D;l2-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               curnode-&gt;next&#x3D;l1;</span><br><span class="line">               l1&#x3D;l1-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           curnode &#x3D; curnode -&gt; next;</span><br><span class="line">       &#125;</span><br><span class="line">       curnode-&gt;next&#x3D; l1&#x3D;&#x3D;nullptr ? l2:l1;</span><br><span class="line">       return former-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h3><p>尝试用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题，<strong>待参考柳婼的解法来补充完整</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h3><p>set容器存储指向结点的指针，遍历这个容器，找得到则有环，找不到则无环</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool hasCycle(ListNode *head) &#123;</span><br><span class="line">       if(head&#x3D;&#x3D;nullptr||head-&gt;next&#x3D;&#x3D;nullptr)</span><br><span class="line">       &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       set&lt;ListNode*&gt;nodeset;&#x2F;&#x2F;set容器内部装指针</span><br><span class="line">       while(head-&gt;next!&#x3D;nullptr)&#x2F;&#x2F;遍历</span><br><span class="line">       &#123;</span><br><span class="line">           if(nodeset.count(head)!&#x3D;0)&#x2F;&#x2F;有这个节点，直接就是环了</span><br><span class="line">           &#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               nodeset.insert(head);&#x2F;&#x2F;没有这个节点就插入</span><br><span class="line">           &#125;</span><br><span class="line">           head&#x3D;head-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;&#x2F;&#x2F;遍历完以后，都没有这个节点，就是没有环</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><hr><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的操作常用到递归和迭代的写法，这和树的特性有关；递归的效率比较低，如果可以改进写法，效率能够提升</p><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><p>左右各一个遍历记录值，递归+=，返回最大值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int maxDepth(TreeNode *root)</span><br><span class="line">   &#123;</span><br><span class="line">       if (root &#x3D;&#x3D; nullptr)</span><br><span class="line">           return 0;</span><br><span class="line">       &#x2F;&#x2F;用递归来写</span><br><span class="line">       int depth_l &#x3D; 1;</span><br><span class="line">       int depth_r &#x3D; 1;</span><br><span class="line">       depth_l +&#x3D; maxDepth(root-&gt;left);</span><br><span class="line">       depth_r +&#x3D; maxDepth(root-&gt;right);</span><br><span class="line">       return depth_l &gt; depth_r ? depth_l : depth_r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p>利用二叉搜索树满足的特性：</p><p><strong>中序遍历</strong>存数据进入vec数组，对数组遍历看是否是升序，是则合格</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void inorder(TreeNode * root,vector&lt;int&gt;&amp; vec)</span><br><span class="line">  &#123;</span><br><span class="line">      if(root&#x3D;&#x3D;NULL)return ;</span><br><span class="line">      inorder(root-&gt;left,vec);</span><br><span class="line">      vec.push_back(root-&gt;val);</span><br><span class="line">      inorder(root-&gt;right,vec);</span><br><span class="line">  &#125;</span><br><span class="line">  bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">      vector&lt;int&gt;vec;</span><br><span class="line">      inorder(root,vec);</span><br><span class="line">      for(int i&#x3D;1;i&lt;vec.size();++i)</span><br><span class="line">      &#123;</span><br><span class="line">          if(vec[i]&lt;&#x3D;vec[i-1]) return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><p>总函数 isSymmetric借助辅助函数 helper，辅助函数内部写好边界再递归，这样的设计思想需要学习</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool helper(TreeNode * l , TreeNode * r)</span><br><span class="line">  &#123;</span><br><span class="line">      if(l&#x3D;&#x3D;NULL&amp;&amp;r&#x3D;&#x3D;NULL) return true;</span><br><span class="line">      if(l&#x3D;&#x3D;NULL||r&#x3D;&#x3D;NULL) return false;</span><br><span class="line">      if(l-&gt;val!&#x3D;r-&gt;val) return false;</span><br><span class="line">      return helper(l-&gt;left,r-&gt;right)&amp;helper(l-&gt;right,r-&gt;left); &#x2F;&#x2F;这句话是精髓</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">      if(!root) return true;</span><br><span class="line">      return helper(root-&gt;left,root-&gt;right);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><h3 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102.二叉树的层次遍历"></a>102.二叉树的层次遍历</h3><p>用数组vector和队列queue解决</p><p>队列牢牢地掌控了层次遍历的顺序</p><p>vector<int>为了vector&lt;vector<int>&gt;服务</int></int></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode *root)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; row;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        if (root &#x3D;&#x3D; NULL)</span><br><span class="line">            return ret;</span><br><span class="line">        TreeNode *temp;</span><br><span class="line">        que.push(root);</span><br><span class="line">        while (!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int size &#x3D; que.size();</span><br><span class="line">            while (size--) &#x2F;&#x2F;把同一层的放到一起</span><br><span class="line">            &#123;</span><br><span class="line">                temp &#x3D; que.front(); &#x2F;&#x2F;先留个号码，好找</span><br><span class="line">                que.pop();          &#x2F;&#x2F;再出队</span><br><span class="line">                row.push_back(temp-&gt;val);</span><br><span class="line">                if (temp-&gt;left !&#x3D; NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (temp-&gt;right !&#x3D; NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(row);</span><br><span class="line">            row.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><p>核心在于有序数组的中间值是根节点，代码虽短，细节不少</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty()) return nullptr;</span><br><span class="line">        return helper(nums,0,nums.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode * helper(vector&lt;int&gt;&amp;nums,int left,int right)</span><br><span class="line">    &#123;</span><br><span class="line">        if(left&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid&#x3D;(left+right)&#x2F;2; &#x2F;&#x2F;升序的有序数组变成平衡二叉树，根节点一定在中点的位置</span><br><span class="line">        TreeNode * root &#x3D; new TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left&#x3D;helper(nums,left,mid-1);</span><br><span class="line">        root-&gt;right&#x3D;helper(nums,mid+1,right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><hr><h2 id="排序和搜索"><a href="#排序和搜索" class="headerlink" title="排序和搜索"></a>排序和搜索</h2><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h3><p>几个边界，写错了两次，需要多注意</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">       if(!m) &#123;</span><br><span class="line">           swap(nums1,nums2);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       if(!n)&#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       int k1&#x3D;m-1;</span><br><span class="line">       int k2&#x3D;n-1;</span><br><span class="line">       int k3&#x3D;n+m-1;</span><br><span class="line">       while(k1&gt;&#x3D;0&amp;&amp;k2&gt;&#x3D;0)</span><br><span class="line">       &#123;</span><br><span class="line">           &#x2F;&#x2F;前面是判断，后面是执行</span><br><span class="line">           nums1[k3--]&#x3D;nums1[k1]&gt;nums2[k2]?nums1[k1--]:nums2[k2--];</span><br><span class="line">       &#125;</span><br><span class="line">       while(k2&gt;&#x3D;0)</span><br><span class="line">       &#123;</span><br><span class="line">           nums1[k3--]&#x3D;nums2[k2--];</span><br><span class="line">       &#125;&#x2F;&#x2F;避免nums1走完，nums2没走完的情况</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278.第一个错误的版本"></a>278.第一个错误的版本</h3><p>二分查找法，可以通过递归和迭代两种方式实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int firstBadVersion(int n) &#123;</span><br><span class="line">       &#x2F;&#x2F;第一直觉是写一个二分查找</span><br><span class="line">       int left&#x3D;1;</span><br><span class="line">       int right&#x3D;n;</span><br><span class="line">       while(left&lt;right)&#x2F;&#x2F;直到left&#x3D;&#x3D;right,找到第一个地方</span><br><span class="line">       &#123;</span><br><span class="line">           int mid&#x3D;left+(right-left)&#x2F;2;&#x2F;&#x2F;避免溢出的精髓之处</span><br><span class="line">           if(isBadVersion(mid)&#x3D;&#x3D;false)</span><br><span class="line">           &#123;</span><br><span class="line">               left&#x3D;mid+1;</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               right&#x3D;mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return left;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><hr><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><p>如何爬上第n节台阶？可以由第n-1节爬一格上来，也可以由n-2节爬2格子上来</p><p>方针：“借助过去，实现现在”</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int climbStairs(int n) &#123;</span><br><span class="line">       int * a &#x3D; new int[n+1];</span><br><span class="line">       a[0]&#x3D;1; &#x2F;&#x2F;把n从0开始的所有情况，涵盖了进来</span><br><span class="line">       a[1]&#x3D;1;</span><br><span class="line">       for(int i&#x3D;2;i&lt;&#x3D;n;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           a[i]&#x3D;a[i-1]+a[i-2];</span><br><span class="line">       &#125;</span><br><span class="line">       return a[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h3><p>一次遍历实现，之前记录的profit为现在的ret提供了参考</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        int profit;</span><br><span class="line">        int minpr&#x3D;99999;</span><br><span class="line">        for(int i&#x3D;0;i&lt;prices.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            minpr&#x3D;min(prices[i],minpr);</span><br><span class="line">            profit&#x3D;prices[i]-minpr;</span><br><span class="line">            ret&#x3D;max(profit,ret);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3><p>之前的累加值为现在的选择做出了参考</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       int len &#x3D; nums.size();</span><br><span class="line">       if(len&#x3D;&#x3D;0) return 0;</span><br><span class="line">       int ans &#x3D; nums[0] ;</span><br><span class="line">       int temp &#x3D; nums[0];</span><br><span class="line">       for(int i&#x3D;1;i&lt;len;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           if(temp&gt;0)&#123;</span><br><span class="line">               temp&#x3D;temp+nums[i]; &#x2F;&#x2F;累加值存在temp中，当temp为正，无条件往后累加</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               temp&#x3D;nums[i]; &#x2F;&#x2F;之前的累加值为负，证明是失败的，重新赋予新的累加值temp</span><br><span class="line">           &#125;</span><br><span class="line">           ans&#x3D;max(ans,temp); &#x2F;&#x2F;只返回历史中最大的那个累加值</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h3><p>充分体现动态规划记录数据特性的一道题，<strong>解法值得推敲</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       int n &#x3D; nums.size();</span><br><span class="line">       if(!n) return 0;</span><br><span class="line">       if(n&#x3D;&#x3D;1) return nums[0];</span><br><span class="line">       &#x2F;&#x2F;以三个元素举例，房子1小于房子2价格，现在来到了房子3</span><br><span class="line">       int curmax&#x3D;0;&#x2F;&#x2F;房子2价格</span><br><span class="line">       int premax&#x3D;0;&#x2F;&#x2F;房子1价格</span><br><span class="line">       for(int x:nums)</span><br><span class="line">       &#123;</span><br><span class="line">           int temp&#x3D;curmax;</span><br><span class="line">           curmax&#x3D;max(curmax,(premax+x));</span><br><span class="line">           premax&#x3D;temp;</span><br><span class="line">       &#125;&#x2F;&#x2F;三个int型数据完成全部内容</span><br><span class="line">       return curmax;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><hr><h2 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h2><p>关于设计的这两道题，自己需要加类的成员函数，加类的私有对象</p><h3 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384.打乱数组"></a>384.打乱数组</h3><p>涉及到数组的提前保存和随机数的取得，随机数取得后与还未出场的数进行交换</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt;_nums;</span><br><span class="line">    vector&lt;int&gt;_origin;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    Solution(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        this-&gt;_nums&#x3D;nums;</span><br><span class="line">        this-&gt;_origin&#x3D;nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Resets the array to its original configuration and return it. *&#x2F;</span><br><span class="line">    vector&lt;int&gt; reset() &#123;</span><br><span class="line">        return this-&gt;_origin;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns a random shuffling of the array. *&#x2F;</span><br><span class="line">    vector&lt;int&gt; shuffle() &#123;</span><br><span class="line">        int len&#x3D;_nums.size();</span><br><span class="line">        if(!len) return _nums;</span><br><span class="line">        for(int i&#x3D;len-1;i&gt;&#x3D;0;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            int random &#x3D; rand()%(i+1);</span><br><span class="line">            swap(_nums[random],_nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return _nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h3><p>借用辅助栈来实现以空间换时间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt;sta;</span><br><span class="line">    stack&lt;int&gt;min;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        sta.push(x);</span><br><span class="line">        if(min.empty()||x&lt;&#x3D;min.top()) &#x2F;&#x2F;&#x3D;防止出现连续两个最小的-10</span><br><span class="line">        &#123;</span><br><span class="line">            min.push(x);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(sta.top()&#x3D;&#x3D;min.top())</span><br><span class="line">        &#123;</span><br><span class="line">            min.pop();</span><br><span class="line">        &#125;    </span><br><span class="line">            sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        return sta.top();    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int getMin() &#123;</span><br><span class="line">        return min.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><hr><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412.Fizz Buzz"></a>412.Fizz Buzz</h3><p>数学问题，对症下药</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; fizzBuzz(int n)</span><br><span class="line">   &#123;</span><br><span class="line">       vector&lt;string&gt; ret;</span><br><span class="line">       for (int i &#x3D; 1; i &lt;&#x3D; n; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">           if (i % 15 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">               ret.push_back(&quot;FizzBuzz&quot;);</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if (i % 3 &#x3D;&#x3D; 0 )&#123;</span><br><span class="line">               ret.push_back(&quot;Fizz&quot;);</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if (i % 5 &#x3D;&#x3D; 0 )&#123;</span><br><span class="line">               ret.push_back(&quot;Buzz&quot;);</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               ret.push_back(to_string(i));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204.计数质数"></a>204.计数质数</h3><p>关于质数，有个很神奇的筛法，叫<strong>“厄拉多塞筛法”</strong></p><p>核心思想是，当一个数确定为质数后，它的倍数全部都不会是质数，筛掉</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int countPrimes(int n) &#123;</span><br><span class="line">       int count&#x3D;0;</span><br><span class="line">       vector&lt;bool&gt;vec(n,true);</span><br><span class="line">       for(int i&#x3D;2;i&lt;n;++i)&#x2F;&#x2F;从2这第一个质数开始</span><br><span class="line">       &#123;</span><br><span class="line">           if(vec[i])</span><br><span class="line">           &#123;</span><br><span class="line">               ++count;</span><br><span class="line">               for(int j&#x3D;i+i;j&lt;n;j+&#x3D;i)</span><br><span class="line">               &#123;</span><br><span class="line">                   vec[j]&#x3D;false;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p><strong>优化操作：用bitmap对筛选算法进行内存优化</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int countPrimes(int n) &#123;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;一个 int 变量不知道占多少字节（但请注意，这里采用了常量）</span><br><span class="line">    const int size &#x3D; sizeof(int) * 8;</span><br><span class="line">    vector&lt;int&gt; signs(n &#x2F; size + 1,0);</span><br><span class="line">    for (int i &#x3D; 2; i &lt; n; i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;将元素和需确定得数字经行按位或运算，如果值改变，说明不存在该数字（未登记该数字），则其为质数。</span><br><span class="line">        &#x2F;&#x2F;在C++中，其提供了 bitset 来操作位，在此便不做介绍了。如果用了，可读性肯定会更好。</span><br><span class="line">        &#x2F;&#x2F;(当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值)</span><br><span class="line">        &#x2F;&#x2F;*如果 x &#x3D; 2^n ，则 x &amp; (n - 1) &#x3D;&#x3D; x % n</span><br><span class="line">        &#x2F;&#x2F;下面判断可以写成</span><br><span class="line">        &#x2F;&#x2F;if ((signs[i &#x2F; size] &amp; (1 &lt;&lt; (i % 32))) &#x3D;&#x3D; 0)</span><br><span class="line">        if ((signs[i &#x2F; size] &amp; (1 &lt;&lt; (i &amp; (size - 1)))) &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            for (int j &#x3D; i + i; j &lt; n; j +&#x3D; i)&#123;</span><br><span class="line">                &#x2F;&#x2F;登记该数字</span><br><span class="line">                signs[j &#x2F; size] |&#x3D; 1 &lt;&lt; (j &amp; (size - 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326.  3的幂"></a>326.  3的幂</h3><p>有很多迭代和递归的写法，这里提供的是非循环和迭代的写法，更为优秀</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">bool isPowerOfThree(int n) &#123;</span><br><span class="line">if(n &lt;&#x3D; 0) return false;</span><br><span class="line">return pow(3, (round)(log(n) &#x2F; log(3))) &#x3D;&#x3D; n; &#x2F;&#x2F;如果是3的幂次，一定是整数次幂</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h3><p>要点：pair的用法 || 罗马数字摆放的本质规律</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int romanToInt(string s) &#123;</span><br><span class="line">       int ans&#x3D;0;</span><br><span class="line">       map&lt;char,int&gt;mp;</span><br><span class="line">       char roman[]&#x3D;&#123;&#39;I&#39;,&#39;V&#39;,&#39;X&#39;,&#39;L&#39;,&#39;C&#39;,&#39;D&#39;,&#39;M&#39;&#125;;</span><br><span class="line">       int val[]&#x3D;&#123;1,5,10,50,100,500,1000&#125;;</span><br><span class="line">       for(int i&#x3D;0;i&lt;7;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           mp.insert(pair&lt;char,int&gt;(roman[i],val[i]));</span><br><span class="line">       &#125;</span><br><span class="line">       for(int i&#x3D;0;i&lt;s.size()-1;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           if(mp[s[i]]&gt;&#x3D;mp[s[i+1]])&#123;</span><br><span class="line">               ans+&#x3D;mp[s[i]];</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               ans-&#x3D;mp[s[i]];</span><br><span class="line">           &#125;&#x2F;&#x2F;成功解决IX类型写法，看透了本质</span><br><span class="line">       &#125;</span><br><span class="line">       ans+&#x3D;mp[s[s.size()-1]];</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191.位1的个数"></a>191.位1的个数</h3><p>涉及到“位bit”，与或非操作不可忘！</p><p>迭代法是基础</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int hammingWeight(uint32_t n)  &#x2F;&#x2F;传进来的是32位的2进制数</span><br><span class="line">   &#123; </span><br><span class="line">       int ret &#x3D; 0;</span><br><span class="line">       uint32_t mask &#x3D; 1;</span><br><span class="line">       for (int i &#x3D; 0; i &lt; 32; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">           if ((n &amp; mask) !&#x3D; 0)</span><br><span class="line">           &#123;</span><br><span class="line">               ++ret;</span><br><span class="line">           &#125;</span><br><span class="line">           mask &#x3D; mask &lt;&lt; 1;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461.汉明距离"></a>461.汉明距离</h3><p>实质是找出有几个位是不同的，异或、与操作、算术右移</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int hammingDistance(int x, int y) &#123;</span><br><span class="line">       int count&#x3D;0;</span><br><span class="line">       int xor1&#x3D;x^y;&#x2F;&#x2F;异或后，不同的位留下的都是1</span><br><span class="line">       while(xor1&gt;0)</span><br><span class="line">       &#123;</span><br><span class="line">           if(xor1&amp;1&#x3D;&#x3D;1)&#x2F;&#x2F;把所有的1数出来，用与的方法</span><br><span class="line">           &#123;</span><br><span class="line">               ++count; </span><br><span class="line">           &#125;</span><br><span class="line">           xor1&gt;&gt;&#x3D;1; &#x2F;&#x2F;算术右移一位</span><br><span class="line">       &#125;</span><br><span class="line">       return count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190.颠倒二进制位"></a>190.颠倒二进制位</h3><p>pop || x || ret 经典搭配，实现 逆置一个数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint32_t reverseBits(uint32_t n) &#123;</span><br><span class="line">       uint32_t ret &#x3D; 0;</span><br><span class="line">       uint32_t pop &#x3D; 0;</span><br><span class="line">       for(int i&#x3D;0;i&lt;32;++i)&#123;</span><br><span class="line">           pop&#x3D;n%2;</span><br><span class="line">           n&#x3D;n&#x2F;2;</span><br><span class="line">           ret&#x3D;ret*2+pop;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="118-帕斯卡三角-杨辉三角"><a href="#118-帕斯卡三角-杨辉三角" class="headerlink" title="118.帕斯卡三角/杨辉三角"></a>118.帕斯卡三角/杨辉三角</h3><p>考察vector创建二维数组的操作，<strong>需要多练</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; v(numRows);</span><br><span class="line">if(numRows &#x3D;&#x3D; 0) return v;</span><br><span class="line">for(int i &#x3D; 0; i &lt; numRows; i++) &#123;</span><br><span class="line">v[i].resize(i + 1);</span><br><span class="line">&#125;</span><br><span class="line">v[0][0] &#x3D; 1;</span><br><span class="line">if(numRows &#x3D;&#x3D; 1) return v;</span><br><span class="line">v[1][0] &#x3D; 1;</span><br><span class="line">v[1][1] &#x3D; 1;</span><br><span class="line">for(int i &#x3D; 2; i &lt; numRows; i++) &#123;</span><br><span class="line">v[i][0] &#x3D; 1;</span><br><span class="line">v[i][i] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; 2; i &lt; numRows; i++) &#123;</span><br><span class="line">for(int j &#x3D; 1; j &lt; i; j++) &#123;</span><br><span class="line">v[i][j] &#x3D; v[i - 1][j - 1] + v[i - 1][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><p>核心是栈的入栈和出栈</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool isValid(string s) &#123;</span><br><span class="line">      stack&lt;char&gt;sta;</span><br><span class="line">      int len &#x3D; s.size();</span><br><span class="line">      if(!len) return true;</span><br><span class="line">      if(len%2&#x3D;&#x3D;1) return false;&#x2F;&#x2F;先把边界条件写好</span><br><span class="line">      for(int i&#x3D;0;i&lt;len;++i)&#123;</span><br><span class="line">           if(sta.empty())&#123;</span><br><span class="line">               sta.push(s[i]);</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if(sta.top()&#x3D;&#x3D;&#39;(&#39;&amp;&amp;s[i]&#x3D;&#x3D;&#39;)&#39;)&#123;</span><br><span class="line">               sta.pop();</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if(sta.top()&#x3D;&#x3D;&#39;[&#39;&amp;&amp;s[i]&#x3D;&#x3D;&#39;]&#39;)&#123;</span><br><span class="line">               sta.pop();</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if(sta.top()&#x3D;&#x3D;&#39;&#123;&#39;&amp;&amp;s[i]&#x3D;&#x3D;&#39;&#125;&#39;)&#123;</span><br><span class="line">               sta.pop();</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           sta.push(s[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      return sta.empty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h3 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268.缺失数字"></a>268.缺失数字</h3><p>观察规律，然后解决</p><p>代码里写了两种遍历方式，后者效率更高</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       int len&#x3D;nums.size();</span><br><span class="line">       int total&#x3D;(0+len)*(len+1)&#x2F;2;</span><br><span class="line">       for(int x : nums)</span><br><span class="line">       &#123;</span><br><span class="line">           total-&#x3D;x;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; for(int i&#x3D;0;i&lt;len;++i)</span><br><span class="line">       &#x2F;&#x2F; &#123;</span><br><span class="line">       &#x2F;&#x2F;     total-&#x3D;nums[i];</span><br><span class="line">       &#x2F;&#x2F; &#125;</span><br><span class="line">       return total;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;leetcode初级算法——代码笔记整理&quot;&gt;&lt;a href=&quot;#leetcode初级算法——代码笔记整理&quot; class=&quot;headerlink&quot; title=&quot;leetcode初级算法——代码笔记整理&quot;&gt;&lt;/a&gt;leetcode初级算法——代码笔记整理&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>《活着》读书笔记</title>
    <link href="http://yoursite.com/2020/02/12/%E3%80%8A%E6%B4%BB%E7%9D%80%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/02/12/%E3%80%8A%E6%B4%BB%E7%9D%80%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-02-12T00:49:44.000Z</published>
    <updated>2020-04-05T01:39:06.940Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这是作家余华最成功的的作品之一，很多人说中短篇小说是余华最擅长的领域，作为一篇中篇小说，我用两天晚上看完了这本书。作者用特化的表现手法，把那一代人遭受的苦难都集中表现在了福贵一家的身上，看得人热泪盈眶，偶觉喘不过气。常常在想，把自己代入福贵的人生，自己该如何活着？活着是题目，也是贯穿全书的主旨<br>厚重的历史感沉淀在这本书里，把远离那个年代的我们自然而然地带入了进去<br>看完书，最大的感受是，何为活着，何为生命的意义？引人深思</p><h3 id="书后惑"><a href="#书后惑" class="headerlink" title="书后惑"></a>书后惑</h3><p>我提出几个问题，供我今后思考，也供看到了本文的读者思考：<br>1.福贵在经历了那么多苦难以后，他自己是如何思考如何活着？中间的认知有哪些变化？<br>2.小说后半段二喜 苦根的死，是否处理太过迅速，令稍显麻木的读者来不及共情？<br>3.看完了本书，你如何思考在当下世界，我们如何活着？</p><h3 id="贯彻全文的话"><a href="#贯彻全文的话" class="headerlink" title="贯彻全文的话"></a>贯彻全文的话</h3><p>“活着，不是为了什么而活着，活着就是为了活着而活着”</p><h3 id="著名书评"><a href="#著名书评" class="headerlink" title="著名书评"></a>著名书评</h3><p>《时代》周刊：中国过去六十年所发生的一切灾难，都一一发生在福贵和他的家庭身上。接踵而至的打击或许令读者无从同情，但余华至真至诚的笔墨，已将福贵塑造成了一个存在的英雄。当这部沉重的小说结束时，活着的意志，是福贵身上唯一不能被剥夺走的东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;这是作家余华最成功的的作品之一，很多人说中短篇小说是余华最擅长的领域，作为一篇中篇小说，我用两天晚上看完了这本书。作者用特化的表现手法，把那
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="余华" scheme="http://yoursite.com/tags/%E4%BD%99%E5%8D%8E/"/>
    
  </entry>
  
  <entry>
    <title>《误杀》观后感</title>
    <link href="http://yoursite.com/2020/01/24/%E3%80%8A%E8%AF%AF%E6%9D%80%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    <id>http://yoursite.com/2020/01/24/%E3%80%8A%E8%AF%AF%E6%9D%80%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/</id>
    <published>2020-01-24T00:29:01.000Z</published>
    <updated>2020-02-12T01:02:48.535Z</updated>
    
    <content type="html"><![CDATA[<p>先给评价，这是今年的中国十佳电影之一，也是翻拍外国电影的优秀改编作品。</p><p>电影故事是飞轮型的电影，前面堆积细节和证据，后面加速进程。肖央、程卓、陈冲为主演的演员群体演技全部在线，剧本质量过硬，节奏感和配乐都十分出色，下面谈谈<strong>印象最深的几点</strong>：</p><ol><li>男主李维杰和阿温是正反双方十分近似的人物，一个看过1000部电影觉着世间没有离奇事情；一个审过1000多个案件，没有离奇的案子；从一开始，对角线般一正一邪的人物就出场了，暗暗较劲；电影开始时的挖地道和结尾的挖地道构成一种轮回的关系，了解这个故事的男主如何抉择留下了悬念；陈志朋演的被审问者引出了女警官的出场，陈志朋的脸看起来很面熟；</li><li>蒙太奇的手法不只是电影开始明确提到过，更是在大女儿误杀的时候充分运用，在李维杰伪造证据的时候也运用了时空蒙太奇</li><li>小女儿在餐桌上用叉子一直划来划去，发出锐利的声音暗示着小女儿知道并且听到了假死的素察在棺材里挣扎的情况，结尾的棺材里的血迹也印证了这一点</li><li>李维杰是个有着坚强性格的男人，为家人愿意承担一切；平时经常去做布告，当安排好伪证之后，再去布告被僧人拒绝，我想是他最后自首的原因之一；另外还有一点，女儿在这次事件之后，涂改了成绩单学会了撒谎，这也是李维杰不愿意看到的。女儿和父亲之间本身有着隔阂，也在这个事件之后得到改善</li><li>素察的爸爸，为了选举一秒变脸的政客，这个细节镜头给我留下了深刻印象，一切都不如他的政治前提重要，一巴掌就打向了犯错的儿子；素察的母亲也就是阿温，警察局长为达目的不择手段但是溺爱儿子，这是形成这个悲剧的根源；事后忏悔又有什么用呢？</li><li>两个母亲在警局对峙的时候，特写镜头拍出了两个母亲之间的直接交锋，都是为了自己的孩子，母亲的战斗力此时无限大</li><li>我并不知道这是否是为了过审，男主最后选择了自首，这也可以解释为李维杰为了心里安慰，为了给孩子树立榜样，但我抱有这样的怀疑</li><li>羊，这个概念多次用到并且具有重要用途，既是替罪羊，又是迷群者的代名词，还有一层佛教的特殊释义，结尾的“替罪羊”更是经验，配合当时的雨点特效堪称戏剧反转的典范</li><li>本片的主题，误杀，谁对谁错呢？每个人都有自己的答案，我认同最后李维杰的选择，真相呢如同最后受采访大爷的那不语一笑，引人遐想</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先给评价，这是今年的中国十佳电影之一，也是翻拍外国电影的优秀改编作品。&lt;/p&gt;
&lt;p&gt;电影故事是飞轮型的电影，前面堆积细节和证据，后面加速进程。肖央、程卓、陈冲为主演的演员群体演技全部在线，剧本质量过硬，节奏感和配乐都十分出色，下面谈谈&lt;strong&gt;印象最深的几点&lt;/st
      
    
    </summary>
    
    
      <category term="观后感" scheme="http://yoursite.com/categories/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>《社会性动物》读书笔记</title>
    <link href="http://yoursite.com/2020/01/19/%E3%80%8A%E7%A4%BE%E4%BC%9A%E6%80%A7%E5%8A%A8%E7%89%A9%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/01/19/%E3%80%8A%E7%A4%BE%E4%BC%9A%E6%80%A7%E5%8A%A8%E7%89%A9%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-19T12:47:49.000Z</published>
    <updated>2020-01-25T15:32:36.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《社会性动物》目录"><a href="#《社会性动物》目录" class="headerlink" title="《社会性动物》目录"></a>《社会性动物》目录</h2><h3 id="什么是社会心理学"><a href="#什么是社会心理学" class="headerlink" title="什么是社会心理学"></a>什么是社会心理学</h3><h3 id="从众"><a href="#从众" class="headerlink" title="从众"></a>从众</h3><h3 id="大众传播、宣传、劝导"><a href="#大众传播、宣传、劝导" class="headerlink" title="大众传播、宣传、劝导"></a>大众传播、宣传、劝导</h3><h3 id="社会认知"><a href="#社会认知" class="headerlink" title="社会认知"></a>社会认知</h3><h3 id="自我辩解"><a href="#自我辩解" class="headerlink" title="自我辩解"></a>自我辩解</h3><h3 id="人类的攻击性"><a href="#人类的攻击性" class="headerlink" title="人类的攻击性"></a>人类的攻击性</h3><h3 id="偏见"><a href="#偏见" class="headerlink" title="偏见"></a>偏见</h3><h3 id="喜欢、爱和人际敏感性"><a href="#喜欢、爱和人际敏感性" class="headerlink" title="喜欢、爱和人际敏感性"></a>喜欢、爱和人际敏感性</h3><h3 id="作为一门科学的社会心理学"><a href="#作为一门科学的社会心理学" class="headerlink" title="作为一门科学的社会心理学"></a>作为一门科学的社会心理学</h3><hr><p>本书采用三点读书法：</p><p>我仔细阅读了二三四八九章节</p><p>把下面总结三个核心出来</p><hr><h3 id="从众章节"><a href="#从众章节" class="headerlink" title="从众章节"></a>从众章节</h3><p><strong>从众：任何一项具体的行动都可以归因于依从、认同和同化</strong></p><p>以超速处罚为例，严厉检查会限制人们想超速的心理，这是依从；因为有人不超速取得了好的效果，超速取得了坏的效果，人们逐渐认同不要超速这一观念；最好，人们认为不要超速确实很好，会帮助到自己，这是同化</p><p>起决定性作用的因素：依从——权力    认同——吸引    同化——可信度</p><h3 id="社会认知章节："><a href="#社会认知章节：" class="headerlink" title="社会认知章节："></a>社会认知章节：</h3><p><strong>人们不喜欢失去而总是试图避免受到损失</strong>。失去 20 美元要比得到 20 美元更使人痛苦。</p><p>原来的A计划，可以挽救200条命；原来的B计划600人获救的可能性为1/3，全部丧生的可能性为2/3</p><p>72%的被试人选择A计划</p><p>给计划换个说法，采用A计划，400人会丧生；采用B计划，全部获救的可能性为1/3，600人丧生的可能性为2/3</p><p>78%的人选择B</p><p>你的顾问设计的第一套方案，让 b 计划看起来遭受的损失多一些；你的顾问设计了第二套方案，使 a 计划看上去落选无疑。因此，问题的设计方式非常重要</p><h3 id="喜欢、爱和人际敏感性章节："><a href="#喜欢、爱和人际敏感性章节：" class="headerlink" title="喜欢、爱和人际敏感性章节："></a>喜欢、爱和人际敏感性章节：</h3><p><strong>“增——减”喜爱理论</strong></p><p>增加的喜爱比从头到尾一直喜爱的作用更大，人们更喜欢前者；</p><p>减少的喜爱比从头到尾一直否定的作用更大，前者影响更深</p><p>在长时间的亲密关系里，这个理论作用提现在：长时间恋人之间的夸赞可能不会起到这么好的效果，早就听过；一个批评或者冷淡就会给人以迅速减少的喜爱的感觉</p><p>个人感悟：想和一个人搞好关系，增加的喜爱更会让人记住你对它的喜爱，而不是从一开始就如此热情；</p><hr><h3 id="原文摘抄："><a href="#原文摘抄：" class="headerlink" title="原文摘抄："></a>原文摘抄：</h3><ol><li>看起来亲密关系天然地固有一种基本的讽刺，用著名民谣中的一句话说就是，“你总是伤害你所爱的人”。为什么会这样呢？回想我们以前关于增减理论的讨论中的那个令人吃惊的事实：我们发现，当某人最初对我们否定的态度渐渐转变为肯定的态度时，我们会觉得这是比某人一直完全对我们持肯定态度更大的酬赏。</li><li>外貌的吸引力是一个非常重要的因素；但是在这种情形之中，决定这种关系是否具有保持下去可能性的最重要因素是这些恋人们的吸引力是否相似</li><li>我们并不因人们给我们的恩惠而喜爱他们，而是因我们给予了他们恩惠</li></ol><hr><h2 id="全书总结："><a href="#全书总结：" class="headerlink" title="全书总结："></a>全书总结：</h2><p>本书一直在阐述观点的同时以例子佐证，十分翔实和具有说服力；我觉着看这本用大量例子和阐述写成的书，应该是带着自己的疑惑来进入看书的环节，捋清目录顺序后，直奔最想看的章节；带着兴趣来读这本书是最好的方法，接下来有疑惑我还会回到这本书</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;《社会性动物》目录&quot;&gt;&lt;a href=&quot;#《社会性动物》目录&quot; class=&quot;headerlink&quot; title=&quot;《社会性动物》目录&quot;&gt;&lt;/a&gt;《社会性动物》目录&lt;/h2&gt;&lt;h3 id=&quot;什么是社会心理学&quot;&gt;&lt;a href=&quot;#什么是社会心理学&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《为什么精英都是时间控》读书笔记</title>
    <link href="http://yoursite.com/2020/01/17/%E3%80%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B2%BE%E8%8B%B1%E9%83%BD%E6%98%AF%E6%97%B6%E9%97%B4%E6%8E%A7%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/01/17/%E3%80%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B2%BE%E8%8B%B1%E9%83%BD%E6%98%AF%E6%97%B6%E9%97%B4%E6%8E%A7%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-17T09:53:39.000Z</published>
    <updated>2020-02-09T03:38:59.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录概览"><a href="#目录概览" class="headerlink" title="目录概览"></a>目录概览</h2><h3 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h3><h3 id="神之时间管理法四大原则——一、二、三、四"><a href="#神之时间管理法四大原则——一、二、三、四" class="headerlink" title="神之时间管理法四大原则——一、二、三、四"></a>神之时间管理法四大原则——一、二、三、四</h3><h3 id="第一章-最强大脑系列"><a href="#第一章-最强大脑系列" class="headerlink" title="第一章   最强大脑系列"></a>第一章   最强大脑系列</h3><h3 id="第二章-充分利用黄金早上"><a href="#第二章-充分利用黄金早上" class="headerlink" title="第二章   充分利用黄金早上"></a>第二章   充分利用黄金早上</h3><h3 id="第三章-午后休息术"><a href="#第三章-午后休息术" class="headerlink" title="第三章   午后休息术"></a>第三章   午后休息术</h3><h3 id="第四章-晚上如何休息好"><a href="#第四章-晚上如何休息好" class="headerlink" title="第四章   晚上如何休息好"></a>第四章   晚上如何休息好</h3><h3 id="第五章-高效工作术"><a href="#第五章-高效工作术" class="headerlink" title="第五章   高效工作术"></a>第五章   高效工作术</h3><h3 id="第六章-自我投资-复利"><a href="#第六章-自我投资-复利" class="headerlink" title="第六章   自我投资 复利"></a>第六章   自我投资 复利</h3><hr><h4 id="“神之时间管理法”第一原则总结"><a href="#“神之时间管理法”第一原则总结" class="headerlink" title="“神之时间管理法”第一原则总结"></a>“神之时间管理法”第一原则总结</h4><p>工作可分为两种，<strong>专注性工作</strong>和非专注性工作</p><p>专注性工作：创作文章、制作策划书、阅读英语资料、预习C++语法</p><p>非专注性工作：查看电子邮件、打电话、复印文件、开会</p><p>专注性工作应该放在早上，精力好的时候去做</p><p>早上一小时抵晚上两小时；非专注性工作安排到其他时候</p><h4 id="“神之时间管理法”第二原则总结"><a href="#“神之时间管理法”第二原则总结" class="headerlink" title="“神之时间管理法”第二原则总结"></a>“神之时间管理法”第二原则总结</h4><p>“专注力*时间”才是时间效用的真正计算方法</p><p>每天保证充足睡眠，再进行适度有氧运动</p><p>及时休息（番茄工作法45分钟），不要感到累了再休息</p><p>“被动性娱乐”：看电视、玩游戏，除了放松一下，没有好处</p><p>“主动性娱乐”：读书、运动、演奏乐器、棋类游戏，促进自我成长</p><h4 id="早起和提高专注力"><a href="#早起和提高专注力" class="headerlink" title="早起和提高专注力"></a>早起和提高专注力</h4><ul><li>早起原因：早上效率高，把握早上，早上起床后的两三个小时是一天中最好的时间，效用相当于晚上两小时</li><li>轻松早起方法：</li></ul><p>早上冲个澡，睡眠模式的副交感神经切换到白天的交感神经。每天早上会花 5 分钟时间冲淋浴，以换来 3 个小时的高效率工作时间</p><p>“起床冲个澡”和“开着窗帘睡觉”，这两个习惯组合起来，就让我由一个“夜晚活跃型”的人完全转变成了“早晨活跃型”的人。</p><p>中午重启一下，为下午做准备</p><ul><li>排除杂念</li></ul><p>外物造成的杂念：桌上每个物品有着自己的位置，杂乱的状态会影响到一个人；不要为了眼前的省事，为以后造成麻烦</p><p>思考引起的杂念：把心里惦记的事情全部写下来</p><ul><li>提高活力</li></ul><p>日光浴、有节奏的运动、咀嚼</p><h4 id="白天时间法"><a href="#白天时间法" class="headerlink" title="白天时间法"></a>白天时间法</h4><ul><li>外出吃午饭，激活场所神经元；更换场所法，每过45或者90分钟，上个厕所、出去打个水，海马体更活跃</li><li>30分钟的午睡让大脑和身体充分恢复，多睡有害</li><li><strong>最不好的休息方法是玩手机：</strong>从脑科的角度来看，休息时间玩手机是最不好的习惯。因为玩手机，不但不能让大脑休息，反而更加疲劳（处理视觉信息大脑十分疲惫）——闭目养神，阻断视觉信息的输入，效果最好</li><li><strong>给自己设置离开的时间，会提高自己工作时间的工作效率，离开后就放轻松去玩</strong></li><li>不超过一个半小时的运动，利于提高专注力，比如晚上下课去健身房游泳健身</li></ul><h4 id="晚上时间法"><a href="#晚上时间法" class="headerlink" title="晚上时间法"></a>晚上时间法</h4><ul><li>晚上睡觉之前释放压力，例如撸猫，亲密的拥抱，听爱听的音乐，香薰</li><li>睡前两小时该做的事：听音乐、非视觉系放松、爱抚宠物、读书</li><li>睡前两小时不宜做的事：喝酒、剧烈运动、视觉系娱乐（玩电子游戏、看电影）、待在灯光特别明亮处</li><li>睡前十五分钟想些积极向上、饱含正能量的事情，发表微博记录</li><li>养成固定作息习惯，身体会在固定时间做出反应</li></ul><h4 id="日常工作"><a href="#日常工作" class="headerlink" title="日常工作"></a>日常工作</h4><ul><li>两分钟判断术：判断一份工作是现在做还是待会做，遵循“两分钟内完成工作的原则”</li></ul><p>两分钟内可以做完，就现在做——例如，现在就回复邮件而不是过会再打开一遍邮箱浪费30秒</p><p>两分钟内可以完成的工作，现在就马上把它解决，而不是往后拖</p><ul><li>30秒决断术</li></ul><p>日常工作中的决断，只需要30秒思考就够了，“灵感闪现”的正确概率是相当高的</p><ul><li>简单的读书输出法：<strong>3点输出法</strong></li></ul><p>用三个要点来总结这本书给你的收获，每个点只写一行字就够。这种方法写读后感只需要3分钟就够了</p><ul><li>把看电视的时间减少三分之二的方法</li></ul><p>把想看的电视节目录下来，有时间的时候再看；这样可以大幅减少看电视时花费的时间</p><p>想好想看的内容是什么，主动性娱乐，而不是漫无目的地看</p><hr><h4 id="个人全书总结："><a href="#个人全书总结：" class="headerlink" title="个人全书总结："></a>个人全书总结：</h4><p>这是本写的通俗易懂的佳作，自我提升和时间管理类的书籍，想要具有实操性就得牺牲理论严谨度，想要科学严谨就会生涩难度，这本书显然走的前者的道路，对于这方面经验不够丰富的我的来说，系统性的完善自己的时间管理操作，第一步是完善自己的时间管理意识，读完这本书已经达到了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录概览&quot;&gt;&lt;a href=&quot;#目录概览&quot; class=&quot;headerlink&quot; title=&quot;目录概览&quot;&gt;&lt;/a&gt;目录概览&lt;/h2&gt;&lt;h3 id=&quot;序章&quot;&gt;&lt;a href=&quot;#序章&quot; class=&quot;headerlink&quot; title=&quot;序章&quot;&gt;&lt;/a&gt;序章&lt;/h
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
